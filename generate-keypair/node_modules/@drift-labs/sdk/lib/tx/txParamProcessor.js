"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionProcessor = void 0;
const COMPUTE_UNIT_BUFFER_FACTOR = 1.2;
const TEST_SIMS_ALWAYS_FAIL = false;
/**
 * This class is responsible for running through a "processing" pipeline for a base transaction, to adjust the standard transaction parameters based on a given configuration.
 */
class TransactionProcessor {
    static async getComputeUnitsFromSim(txSim) {
        var _a, _b;
        if ((_a = txSim === null || txSim === void 0 ? void 0 : txSim.value) === null || _a === void 0 ? void 0 : _a.unitsConsumed) {
            return (_b = txSim === null || txSim === void 0 ? void 0 : txSim.value) === null || _b === void 0 ? void 0 : _b.unitsConsumed;
        }
        return undefined;
    }
    static async getTxSimComputeUnits(tx, connection) {
        var _a, _b, _c;
        try {
            if (TEST_SIMS_ALWAYS_FAIL)
                throw new Error('Test Error::SIMS_ALWAYS_FAIL');
            const simTxResult = await connection.simulateTransaction(tx, {
                replaceRecentBlockhash: true, // This is important to ensure that the blockhash is not too new.. Otherwise we will very often receive a "blockHashNotFound" error
            });
            if ((_a = simTxResult === null || simTxResult === void 0 ? void 0 : simTxResult.value) === null || _a === void 0 ? void 0 : _a.err) {
                throw new Error((_c = (_b = simTxResult === null || simTxResult === void 0 ? void 0 : simTxResult.value) === null || _b === void 0 ? void 0 : _b.err) === null || _c === void 0 ? void 0 : _c.toString());
            }
            const computeUnits = await this.getComputeUnitsFromSim(simTxResult);
            return {
                success: true,
                computeUnits: computeUnits,
            };
        }
        catch (e) {
            console.warn(`Failed to get Simulated Compute Units for txParamProcessor`, e);
            return {
                success: false,
                computeUnits: undefined,
            };
        }
    }
    static async process(props) {
        var _a;
        // # Exit early if no process config is provided
        if (!props.processConfig || Object.keys(props.processConfig).length === 0) {
            return props.txProps.txParams;
        }
        // # Setup
        const { txProps: txProps, txBuilder: txBuilder, processConfig, processParams: processProps, } = props;
        const finalTxProps = {
            ...txProps,
        };
        // # Run Processes
        if (processConfig.useSimulatedComputeUnits) {
            const txToSim = await txBuilder({
                ...txProps,
                txParams: { ...txProps.txParams, computeUnits: 1400000 },
            });
            const txSimComputeUnitsResult = await this.getTxSimComputeUnits(txToSim, processProps.connection);
            if (txSimComputeUnitsResult.success) {
                const bufferedComputeUnits = txSimComputeUnitsResult.computeUnits *
                    ((_a = processConfig === null || processConfig === void 0 ? void 0 : processConfig.computeUnitsBufferMultiplier) !== null && _a !== void 0 ? _a : COMPUTE_UNIT_BUFFER_FACTOR);
                // Adjust the transaction based on the simulated compute units
                finalTxProps.txParams = {
                    ...txProps.txParams,
                    computeUnits: Math.ceil(bufferedComputeUnits), // Round the compute units to a whole number
                };
            }
        }
        if (processConfig === null || processConfig === void 0 ? void 0 : processConfig.useSimulatedComputeUnitsForCUPriceCalculation) {
            if (!(processConfig === null || processConfig === void 0 ? void 0 : processConfig.useSimulatedComputeUnits)) {
                throw new Error(`encountered useSimulatedComputeUnitsForFees=true, but useSimulatedComputeUnits is false`);
            }
            if (!(processConfig === null || processConfig === void 0 ? void 0 : processConfig.getCUPriceFromComputeUnits)) {
                throw new Error(`encountered useSimulatedComputeUnitsForFees=true, but getComputeUnitPriceFromUnitsToUse helper method is undefined`);
            }
            const simulatedComputeUnits = finalTxProps.txParams.computeUnits;
            const computeUnitPrice = processConfig.getCUPriceFromComputeUnits(simulatedComputeUnits);
            console.debug(`ðŸ”§:: Adjusting compute unit price for simulated compute unit budget :: ${finalTxProps.txParams.computeUnitsPrice}=>${computeUnitPrice}`);
            finalTxProps.txParams.computeUnitsPrice = computeUnitPrice;
        }
        // # Return Final Tx Params
        return finalTxProps.txParams;
    }
}
exports.TransactionProcessor = TransactionProcessor;
