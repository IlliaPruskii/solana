"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTxSender = void 0;
const types_1 = require("./types");
const web3_js_1 = require("@solana/web3.js");
const anchor_1 = require("@coral-xyz/anchor");
const assert_1 = __importDefault(require("assert"));
const bs58_1 = __importDefault(require("bs58"));
const DEFAULT_TIMEOUT = 35000;
const NOT_CONFIRMED_ERROR_CODE = -1001;
class BaseTxSender {
    constructor({ connection, wallet, opts = anchor_1.AnchorProvider.defaultOptions(), timeout = DEFAULT_TIMEOUT, additionalConnections = new Array(), confirmationStrategy = types_1.ConfirmationStrategy.Combo, additionalTxSenderCallbacks, }) {
        this.timeoutCount = 0;
        this.connection = connection;
        this.wallet = wallet;
        this.opts = opts;
        this.timeout = timeout;
        this.additionalConnections = additionalConnections;
        this.confirmationStrategy = confirmationStrategy;
        this.additionalTxSenderCallbacks = additionalTxSenderCallbacks;
    }
    async send(tx, additionalSigners, opts, preSigned, extraConfirmationOptions) {
        if (additionalSigners === undefined) {
            additionalSigners = [];
        }
        if (opts === undefined) {
            opts = this.opts;
        }
        const signedTx = await this.prepareTx(tx, additionalSigners, opts, preSigned);
        if (extraConfirmationOptions === null || extraConfirmationOptions === void 0 ? void 0 : extraConfirmationOptions.onSignedCb) {
            extraConfirmationOptions.onSignedCb();
        }
        return this.sendRawTransaction(signedTx.serialize(), opts);
    }
    async prepareTx(tx, additionalSigners, opts, preSigned) {
        if (preSigned) {
            return tx;
        }
        tx.feePayer = this.wallet.publicKey;
        tx.recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
        additionalSigners
            .filter((s) => s !== undefined)
            .forEach((kp) => {
            tx.partialSign(kp);
        });
        const signedTx = await this.wallet.signTransaction(tx);
        return signedTx;
    }
    async getVersionedTransaction(ixs, lookupTableAccounts, additionalSigners, opts, blockhash) {
        if (additionalSigners === undefined) {
            additionalSigners = [];
        }
        if (opts === undefined) {
            opts = this.opts;
        }
        let recentBlockhash = '';
        if (blockhash) {
            recentBlockhash = blockhash;
        }
        else {
            recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
        }
        const message = new web3_js_1.TransactionMessage({
            payerKey: this.wallet.publicKey,
            recentBlockhash,
            instructions: ixs,
        }).compileToV0Message(lookupTableAccounts);
        const tx = new web3_js_1.VersionedTransaction(message);
        return tx;
    }
    async sendVersionedTransaction(tx, additionalSigners, opts, preSigned, extraConfirmationOptions) {
        let signedTx;
        if (preSigned) {
            signedTx = tx;
            // @ts-ignore
        }
        else if (this.wallet.payer) {
            // @ts-ignore
            tx.sign((additionalSigners !== null && additionalSigners !== void 0 ? additionalSigners : []).concat(this.wallet.payer));
            signedTx = tx;
        }
        else {
            additionalSigners === null || additionalSigners === void 0 ? void 0 : additionalSigners.filter((s) => s !== undefined).forEach((kp) => {
                tx.sign([kp]);
            });
            // @ts-ignore
            signedTx = await this.wallet.signTransaction(tx);
        }
        if (extraConfirmationOptions === null || extraConfirmationOptions === void 0 ? void 0 : extraConfirmationOptions.onSignedCb) {
            extraConfirmationOptions.onSignedCb();
        }
        if (opts === undefined) {
            opts = this.opts;
        }
        return this.sendRawTransaction(signedTx.serialize(), opts);
    }
    async sendRawTransaction(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    rawTransaction, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    opts) {
        throw new Error('Must be implemented by subclass');
    }
    /* Simulate the tx and return a boolean for success value */
    async simulateTransaction(tx) {
        try {
            const result = await this.connection.simulateTransaction(tx);
            if (result.value.err != null) {
                console.error('Error in transaction simulation: ', result.value.err);
                return false;
            }
            return true;
        }
        catch (e) {
            console.error('Error calling simulateTransaction: ', e);
            return false;
        }
    }
    async confirmTransactionWebSocket(signature, commitment) {
        var _a;
        let decodedSignature;
        try {
            decodedSignature = bs58_1.default.decode(signature);
        }
        catch (err) {
            throw new Error('signature must be base58 encoded: ' + signature);
        }
        (0, assert_1.default)(decodedSignature.length === 64, 'signature has invalid length');
        const start = Date.now();
        const subscriptionCommitment = commitment || this.opts.commitment;
        const subscriptionIds = new Array();
        const connections = [this.connection, ...this.additionalConnections];
        let response = null;
        const promises = connections.map((connection, i) => {
            let subscriptionId;
            const confirmPromise = new Promise((resolve, reject) => {
                try {
                    subscriptionId = connection.onSignature(signature, (result, context) => {
                        subscriptionIds[i] = undefined;
                        response = {
                            context,
                            value: result,
                        };
                        resolve(null);
                    }, subscriptionCommitment);
                }
                catch (err) {
                    reject(err);
                }
            });
            subscriptionIds.push(subscriptionId);
            return confirmPromise;
        });
        try {
            await this.promiseTimeout(promises, this.timeout);
        }
        finally {
            for (const [i, subscriptionId] of subscriptionIds.entries()) {
                if (subscriptionId) {
                    connections[i].removeSignatureListener(subscriptionId);
                }
            }
        }
        if (response === null) {
            if (this.confirmationStrategy === types_1.ConfirmationStrategy.Combo) {
                try {
                    const rpcResponse = await this.connection.getSignatureStatus(signature);
                    if ((_a = rpcResponse === null || rpcResponse === void 0 ? void 0 : rpcResponse.value) === null || _a === void 0 ? void 0 : _a.confirmationStatus) {
                        response = {
                            context: rpcResponse.context,
                            value: { err: rpcResponse.value.err },
                        };
                        return response;
                    }
                }
                catch (error) {
                    // Ignore error to pass through to timeout error
                }
            }
            this.timeoutCount += 1;
            const duration = (Date.now() - start) / 1000;
            throw new types_1.TxSendError(`Transaction was not confirmed in ${duration.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature} using the Solana Explorer or CLI tools.`, NOT_CONFIRMED_ERROR_CODE);
        }
        return response;
    }
    async confirmTransactionPolling(signature, commitment = 'finalized') {
        var _a;
        let totalTime = 0;
        let backoffTime = 400; // approx block time
        const start = Date.now();
        while (totalTime < this.timeout) {
            await new Promise((resolve) => setTimeout(resolve, backoffTime));
            const response = await this.connection.getSignatureStatus(signature);
            const result = response && ((_a = response.value) === null || _a === void 0 ? void 0 : _a[0]);
            if (result && result.confirmationStatus === commitment) {
                return { context: result.context, value: { err: null } };
            }
            totalTime += backoffTime;
            backoffTime = Math.min(backoffTime * 2, 5000);
        }
        // Transaction not confirmed within 30 seconds
        this.timeoutCount += 1;
        const duration = (Date.now() - start) / 1000;
        throw new types_1.TxSendError(`Transaction was not confirmed in ${duration.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature} using the Solana Explorer or CLI tools.`, NOT_CONFIRMED_ERROR_CODE);
    }
    async confirmTransaction(signature, commitment) {
        if (this.confirmationStrategy === types_1.ConfirmationStrategy.WebSocket ||
            this.confirmationStrategy === types_1.ConfirmationStrategy.Combo) {
            return await this.confirmTransactionWebSocket(signature, commitment);
        }
        else if (this.confirmationStrategy === types_1.ConfirmationStrategy.Polling) {
            return await this.confirmTransactionPolling(signature, commitment);
        }
    }
    getTimestamp() {
        return new Date().getTime();
    }
    promiseTimeout(promises, timeoutMs) {
        let timeoutId;
        const timeoutPromise = new Promise((resolve) => {
            timeoutId = setTimeout(() => resolve(null), timeoutMs);
        });
        return Promise.race([...promises, timeoutPromise]).then((result) => {
            clearTimeout(timeoutId);
            return result;
        });
    }
    sendToAdditionalConnections(rawTx, opts) {
        var _a;
        this.additionalConnections.map((connection) => {
            connection.sendRawTransaction(rawTx, opts).catch((e) => {
                console.error(
                // @ts-ignore
                `error sending tx to additional connection ${connection._rpcEndpoint}`);
                console.error(e);
            });
        });
        (_a = this.additionalTxSenderCallbacks) === null || _a === void 0 ? void 0 : _a.map((callback) => {
            callback(bs58_1.default.encode(rawTx));
        });
    }
    addAdditionalConnection(newConnection) {
        const alreadyUsingConnection = this.additionalConnections.filter((connection) => {
            // @ts-ignore
            return connection._rpcEndpoint === newConnection.rpcEndpoint;
        }).length > 0;
        if (!alreadyUsingConnection) {
            this.additionalConnections.push(newConnection);
        }
    }
    getTimeoutCount() {
        return this.timeoutCount;
    }
}
exports.BaseTxSender = BaseTxSender;
