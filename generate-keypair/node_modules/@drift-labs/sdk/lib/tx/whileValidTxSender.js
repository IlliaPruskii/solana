"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhileValidTxSender = void 0;
const web3_js_1 = require("@solana/web3.js");
const anchor_1 = require("@coral-xyz/anchor");
const baseTxSender_1 = require("./baseTxSender");
const bs58_1 = __importDefault(require("bs58"));
const DEFAULT_RETRY = 2000;
const PLACEHOLDER_BLOCKHASH = 'Fdum64WVeej6DeL85REV9NvfSxEJNPZ74DBk7A8kTrKP';
class WhileValidTxSender extends baseTxSender_1.BaseTxSender {
    constructor({ connection, wallet, opts = { ...anchor_1.AnchorProvider.defaultOptions(), maxRetries: 0 }, retrySleep = DEFAULT_RETRY, additionalConnections = new Array(), additionalTxSenderCallbacks = [], blockhashCommitment = 'finalized', }) {
        super({
            connection,
            wallet,
            opts,
            additionalConnections,
            additionalTxSenderCallbacks,
        });
        this.timoutCount = 0;
        this.untilValid = new Map();
        this.retrySleep = retrySleep;
        this.blockhashCommitment = blockhashCommitment;
    }
    async sleep(reference) {
        return new Promise((resolve) => {
            reference.resolve = resolve;
            setTimeout(resolve, this.retrySleep);
        });
    }
    async prepareTx(tx, additionalSigners, opts, preSigned) {
        var _a;
        const latestBlockhash = await this.connection.getLatestBlockhash(this.blockhashCommitment);
        // handle tx
        let signedTx = tx;
        if (!preSigned) {
            tx.feePayer = this.wallet.publicKey;
            tx.recentBlockhash = latestBlockhash.blockhash;
            additionalSigners
                .filter((s) => s !== undefined)
                .forEach((kp) => {
                tx.partialSign(kp);
            });
            signedTx = await this.wallet.signTransaction(tx);
        }
        // handle subclass-specific side effects
        const txSig = bs58_1.default.encode(((_a = signedTx.signatures[0]) === null || _a === void 0 ? void 0 : _a.signature) || signedTx.signatures[0]);
        this.untilValid.set(txSig, latestBlockhash);
        return signedTx;
    }
    async getVersionedTransaction(ixs, lookupTableAccounts, _additionalSigners, _opts, blockhash) {
        const message = new web3_js_1.TransactionMessage({
            payerKey: this.wallet.publicKey,
            recentBlockhash: blockhash !== null && blockhash !== void 0 ? blockhash : PLACEHOLDER_BLOCKHASH,
            instructions: ixs,
        }).compileToV0Message(lookupTableAccounts);
        const tx = new web3_js_1.VersionedTransaction(message);
        return tx;
    }
    async sendVersionedTransaction(tx, additionalSigners, opts, preSigned, extraConfirmationOptions) {
        const latestBlockhash = await this.connection.getLatestBlockhash(this.blockhashCommitment);
        let signedTx;
        if (preSigned) {
            signedTx = tx;
            // @ts-ignore
        }
        else if (this.wallet.payer) {
            tx.message.recentBlockhash = latestBlockhash.blockhash;
            // @ts-ignore
            tx.sign((additionalSigners !== null && additionalSigners !== void 0 ? additionalSigners : []).concat(this.wallet.payer));
            signedTx = tx;
        }
        else {
            tx.message.recentBlockhash = latestBlockhash.blockhash;
            additionalSigners === null || additionalSigners === void 0 ? void 0 : additionalSigners.filter((s) => s !== undefined).forEach((kp) => {
                tx.sign([kp]);
            });
            // @ts-ignore
            signedTx = await this.wallet.signTransaction(tx);
        }
        if (extraConfirmationOptions === null || extraConfirmationOptions === void 0 ? void 0 : extraConfirmationOptions.onSignedCb) {
            extraConfirmationOptions.onSignedCb();
        }
        if (opts === undefined) {
            opts = this.opts;
        }
        const txSig = bs58_1.default.encode(signedTx.signatures[0]);
        this.untilValid.set(txSig, latestBlockhash);
        return this.sendRawTransaction(signedTx.serialize(), opts);
    }
    async sendRawTransaction(rawTransaction, opts) {
        const startTime = this.getTimestamp();
        const txid = await this.connection.sendRawTransaction(rawTransaction, opts);
        this.sendToAdditionalConnections(rawTransaction, opts);
        let done = false;
        const resolveReference = {
            resolve: undefined,
        };
        const stopWaiting = () => {
            done = true;
            if (resolveReference.resolve) {
                resolveReference.resolve();
            }
        };
        (async () => {
            while (!done && this.getTimestamp() - startTime < this.timeout) {
                await this.sleep(resolveReference);
                if (!done) {
                    this.connection
                        .sendRawTransaction(rawTransaction, opts)
                        .catch((e) => {
                        console.error(e);
                        stopWaiting();
                    });
                    this.sendToAdditionalConnections(rawTransaction, opts);
                }
            }
        })();
        let slot;
        try {
            const { blockhash, lastValidBlockHeight } = this.untilValid.get(txid);
            const result = await this.connection.confirmTransaction({
                signature: txid,
                lastValidBlockHeight,
                blockhash,
            }, opts.commitment);
            slot = result.context.slot;
            // eslint-disable-next-line no-useless-catch
        }
        catch (e) {
            throw e;
        }
        finally {
            stopWaiting();
        }
        return { txSig: txid, slot };
    }
}
exports.WhileValidTxSender = WhileValidTxSender;
