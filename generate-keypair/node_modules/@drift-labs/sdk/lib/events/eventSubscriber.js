"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventSubscriber = void 0;
const types_1 = require("./types");
const txEventCache_1 = require("./txEventCache");
const eventList_1 = require("./eventList");
const pollingLogProvider_1 = require("./pollingLogProvider");
const fetchLogs_1 = require("./fetchLogs");
const webSocketLogProvider_1 = require("./webSocketLogProvider");
const events_1 = require("events");
const sort_1 = require("./sort");
const parse_1 = require("./parse");
class EventSubscriber {
    constructor(connection, program, options = types_1.DefaultEventSubscriptionOptions) {
        var _a;
        this.connection = connection;
        this.program = program;
        this.options = options;
        this.awaitTxPromises = new Map();
        this.awaitTxResolver = new Map();
        this.options = Object.assign({}, types_1.DefaultEventSubscriptionOptions, options);
        this.address = (_a = this.options.address) !== null && _a !== void 0 ? _a : program.programId;
        this.txEventCache = new txEventCache_1.TxEventCache(this.options.maxTx);
        this.eventListMap = new Map();
        this.eventEmitter = new events_1.EventEmitter();
        if (this.options.logProviderConfig.type === 'websocket') {
            this.logProvider = new webSocketLogProvider_1.WebSocketLogProvider(this.connection, this.address, this.options.commitment, this.options.logProviderConfig.resubTimeoutMs);
        }
        else {
            this.logProvider = new pollingLogProvider_1.PollingLogProvider(this.connection, this.address, options.commitment, this.options.logProviderConfig.frequency, this.options.logProviderConfig.batchSize);
        }
    }
    populateInitialEventListMap() {
        for (const eventType of this.options.eventTypes) {
            this.eventListMap.set(eventType, new eventList_1.EventList(eventType, this.options.maxEventsPerType, (0, sort_1.getSortFn)(this.options.orderBy, this.options.orderDir), this.options.orderDir));
        }
    }
    async subscribe() {
        try {
            if (this.logProvider.isSubscribed()) {
                return true;
            }
            this.populateInitialEventListMap();
            if (this.options.logProviderConfig.type === 'websocket') {
                if (this.options.logProviderConfig.resubTimeoutMs) {
                    if (this.options.logProviderConfig.maxReconnectAttempts &&
                        this.options.logProviderConfig.maxReconnectAttempts > 0) {
                        const logProviderConfig = this.options
                            .logProviderConfig;
                        this.logProvider.eventEmitter.on('reconnect', (reconnectAttempts) => {
                            if (reconnectAttempts > logProviderConfig.maxReconnectAttempts) {
                                console.log('Failing over to polling');
                                this.logProvider.eventEmitter.removeAllListeners('reconnect');
                                this.unsubscribe().then(() => {
                                    this.logProvider = new pollingLogProvider_1.PollingLogProvider(this.connection, this.address, this.options.commitment, logProviderConfig.fallbackFrequency, logProviderConfig.fallbackBatchSize);
                                    this.logProvider.subscribe((txSig, slot, logs, mostRecentBlockTime) => {
                                        this.handleTxLogs(txSig, slot, logs, mostRecentBlockTime);
                                    }, true);
                                });
                            }
                        });
                    }
                }
            }
            this.logProvider.subscribe((txSig, slot, logs, mostRecentBlockTime) => {
                this.handleTxLogs(txSig, slot, logs, mostRecentBlockTime);
            }, true);
            return true;
        }
        catch (e) {
            console.error('Error fetching previous txs in event subscriber');
            console.error(e);
            return false;
        }
    }
    handleTxLogs(txSig, slot, logs, mostRecentBlockTime) {
        if (this.txEventCache.has(txSig)) {
            return;
        }
        const wrappedEvents = this.parseEventsFromLogs(txSig, slot, logs);
        for (const wrappedEvent of wrappedEvents) {
            this.eventListMap.get(wrappedEvent.eventType).insert(wrappedEvent);
        }
        // dont emit event till we've added all the events to the eventListMap
        for (const wrappedEvent of wrappedEvents) {
            this.eventEmitter.emit('newEvent', wrappedEvent);
        }
        if (this.awaitTxPromises.has(txSig)) {
            this.awaitTxPromises.delete(txSig);
            this.awaitTxResolver.get(txSig)();
            this.awaitTxResolver.delete(txSig);
        }
        if (!this.lastSeenSlot || slot > this.lastSeenSlot) {
            this.lastSeenTxSig = txSig;
            this.lastSeenSlot = slot;
        }
        if (this.lastSeenBlockTime === undefined ||
            mostRecentBlockTime > this.lastSeenBlockTime) {
            this.lastSeenBlockTime = mostRecentBlockTime;
        }
        this.txEventCache.add(txSig, wrappedEvents);
    }
    async fetchPreviousTx(fetchMax) {
        if (!this.options.untilTx && !fetchMax) {
            return;
        }
        let txFetched = 0;
        let beforeTx = undefined;
        const untilTx = this.options.untilTx;
        while (txFetched < this.options.maxTx) {
            const response = await (0, fetchLogs_1.fetchLogs)(this.connection, this.address, this.options.commitment === 'finalized' ? 'finalized' : 'confirmed', beforeTx, untilTx);
            if (response === undefined) {
                break;
            }
            txFetched += response.transactionLogs.length;
            beforeTx = response.earliestTx;
            for (const { txSig, slot, logs } of response.transactionLogs) {
                this.handleTxLogs(txSig, slot, logs, response.mostRecentBlockTime);
            }
        }
    }
    async unsubscribe() {
        this.eventListMap.clear();
        this.txEventCache.clear();
        this.awaitTxPromises.clear();
        this.awaitTxResolver.clear();
        return await this.logProvider.unsubscribe(true);
    }
    parseEventsFromLogs(txSig, slot, logs) {
        const records = [];
        // @ts-ignore
        const events = (0, parse_1.parseLogs)(this.program, logs);
        let runningEventIndex = 0;
        for (const event of events) {
            // @ts-ignore
            const expectRecordType = this.eventListMap.has(event.name);
            if (expectRecordType) {
                event.data.txSig = txSig;
                event.data.slot = slot;
                event.data.eventType = event.name;
                event.data.txSigIndex = runningEventIndex;
                records.push(event.data);
            }
            runningEventIndex++;
        }
        return records;
    }
    awaitTx(txSig) {
        if (this.awaitTxPromises.has(txSig)) {
            return this.awaitTxPromises.get(txSig);
        }
        if (this.txEventCache.has(txSig)) {
            return Promise.resolve();
        }
        const promise = new Promise((resolve) => {
            this.awaitTxResolver.set(txSig, resolve);
        });
        this.awaitTxPromises.set(txSig, promise);
        return promise;
    }
    getEventList(eventType) {
        return this.eventListMap.get(eventType);
    }
    /**
     * This requires the EventList be cast to an array, which requires reallocation of memory.
     * Would bias to using getEventList over getEvents
     *
     * @param eventType
     */
    getEventsArray(eventType) {
        return this.eventListMap.get(eventType).toArray();
    }
    getEventsByTx(txSig) {
        return this.txEventCache.get(txSig);
    }
}
exports.EventSubscriber = EventSubscriber;
