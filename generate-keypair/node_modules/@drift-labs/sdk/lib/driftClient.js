"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriftClient = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const bs58_1 = __importDefault(require("bs58"));
const spl_token_1 = require("@solana/spl-token");
const types_1 = require("./types");
const anchor = __importStar(require("@coral-xyz/anchor"));
const drift_json_1 = __importDefault(require("./idl/drift.json"));
const web3_js_1 = require("@solana/web3.js");
const events_1 = require("events");
const pda_1 = require("./addresses/pda");
const utils_1 = require("./tx/utils");
const numericConstants_1 = require("./constants/numericConstants");
const position_1 = require("./math/position");
const spotBalance_1 = require("./math/spotBalance");
const userName_1 = require("./userName");
const pollingDriftClientAccountSubscriber_1 = require("./accounts/pollingDriftClientAccountSubscriber");
const webSocketDriftClientAccountSubscriber_1 = require("./accounts/webSocketDriftClientAccountSubscriber");
const retryTxSender_1 = require("./tx/retryTxSender");
const user_1 = require("./user");
const config_1 = require("./config");
const spotMarkets_1 = require("./constants/spotMarkets");
const userStats_1 = require("./userStats");
const spotPosition_1 = require("./math/spotPosition");
const market_1 = require("./math/market");
const fetch_1 = require("./accounts/fetch");
const spotMarket_1 = require("./math/spotMarket");
const memcmp_1 = require("./memcmp");
const marinade_1 = require("./marinade");
const orderParams_1 = require("./orderParams");
const utils_2 = require("./math/utils");
const txParamProcessor_1 = require("./tx/txParamProcessor");
const oracles_1 = require("./math/oracles");
/**
 * # DriftClient
 * This class is the main way to interact with Drift Protocol. It allows you to subscribe to the various accounts where the Market's state is stored, as well as: opening positions, liquidating, settling funding, depositing & withdrawing, and more.
 */
class DriftClient {
    get isSubscribed() {
        return this._isSubscribed && this.accountSubscriber.isSubscribed;
    }
    set isSubscribed(val) {
        this._isSubscribed = val;
    }
    constructor(config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
        this.users = new Map();
        this._isSubscribed = false;
        this.perpMarketLastSlotCache = new Map();
        this.spotMarketLastSlotCache = new Map();
        this.mustIncludePerpMarketIndexes = new Set();
        this.mustIncludeSpotMarketIndexes = new Set();
        this.connection = config.connection;
        this.wallet = config.wallet;
        this.opts = config.opts || {
            ...anchor_1.AnchorProvider.defaultOptions(),
            commitment: (_a = config === null || config === void 0 ? void 0 : config.connection) === null || _a === void 0 ? void 0 : _a.commitment,
            preflightCommitment: (_b = config === null || config === void 0 ? void 0 : config.connection) === null || _b === void 0 ? void 0 : _b.commitment, // At the moment this ensures that our transaction simulations (which use Connection object) will use the same commitment level as our Transaction blockhashes (which use these opts)
        };
        this.provider = new anchor_1.AnchorProvider(config.connection, 
        // @ts-ignore
        config.wallet, this.opts);
        this.program = new anchor_1.Program(drift_json_1.default, (_c = config.programID) !== null && _c !== void 0 ? _c : new web3_js_1.PublicKey(config_1.DRIFT_PROGRAM_ID), this.provider);
        this.authority = (_d = config.authority) !== null && _d !== void 0 ? _d : this.wallet.publicKey;
        this.activeSubAccountId = (_e = config.activeSubAccountId) !== null && _e !== void 0 ? _e : 0;
        this.skipLoadUsers = (_f = config.skipLoadUsers) !== null && _f !== void 0 ? _f : false;
        this.txVersion = (_g = config.txVersion) !== null && _g !== void 0 ? _g : 'legacy';
        this.txParams = {
            computeUnits: (_j = (_h = config.txParams) === null || _h === void 0 ? void 0 : _h.computeUnits) !== null && _j !== void 0 ? _j : 600000,
            computeUnitsPrice: (_l = (_k = config.txParams) === null || _k === void 0 ? void 0 : _k.computeUnitsPrice) !== null && _l !== void 0 ? _l : 0,
        };
        if (config.includeDelegates && config.subAccountIds) {
            throw new Error('Can only pass one of includeDelegates or subAccountIds. If you want to specify subaccount ids for multiple authorities, pass authoritySubaccountMap instead');
        }
        if (config.authoritySubAccountMap && config.subAccountIds) {
            throw new Error('Can only pass one of authoritySubaccountMap or subAccountIds');
        }
        if (config.authoritySubAccountMap && config.includeDelegates) {
            throw new Error('Can only pass one of authoritySubaccountMap or includeDelegates');
        }
        this.authoritySubAccountMap = config.authoritySubAccountMap
            ? config.authoritySubAccountMap
            : config.subAccountIds
                ? new Map([[this.authority.toString(), config.subAccountIds]])
                : new Map();
        this.includeDelegates = (_m = config.includeDelegates) !== null && _m !== void 0 ? _m : false;
        if (((_o = config.accountSubscription) === null || _o === void 0 ? void 0 : _o.type) === 'polling') {
            this.userAccountSubscriptionConfig = {
                type: 'polling',
                accountLoader: config.accountSubscription.accountLoader,
            };
            this.userStatsAccountSubscriptionConfig = {
                type: 'polling',
                accountLoader: config.accountSubscription.accountLoader,
            };
        }
        else {
            this.userAccountSubscriptionConfig = {
                type: 'websocket',
                resubTimeoutMs: (_p = config.accountSubscription) === null || _p === void 0 ? void 0 : _p.resubTimeoutMs,
                logResubMessages: (_q = config.accountSubscription) === null || _q === void 0 ? void 0 : _q.logResubMessages,
                commitment: (_r = config.accountSubscription) === null || _r === void 0 ? void 0 : _r.commitment,
            };
            this.userStatsAccountSubscriptionConfig = {
                type: 'websocket',
                resubTimeoutMs: (_s = config.accountSubscription) === null || _s === void 0 ? void 0 : _s.resubTimeoutMs,
                logResubMessages: (_t = config.accountSubscription) === null || _t === void 0 ? void 0 : _t.logResubMessages,
                commitment: (_u = config.accountSubscription) === null || _u === void 0 ? void 0 : _u.commitment,
            };
        }
        if (config.userStats) {
            this.userStats = new userStats_1.UserStats({
                driftClient: this,
                userStatsAccountPublicKey: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.authority),
                accountSubscription: this.userAccountSubscriptionConfig,
            });
        }
        this.marketLookupTable = config.marketLookupTable;
        if (config.env && !this.marketLookupTable) {
            this.marketLookupTable = new web3_js_1.PublicKey(config_1.configs[config.env].MARKET_LOOKUP_TABLE);
        }
        const noMarketsAndOraclesSpecified = config.perpMarketIndexes === undefined &&
            config.spotMarketIndexes === undefined &&
            config.oracleInfos === undefined;
        if (((_v = config.accountSubscription) === null || _v === void 0 ? void 0 : _v.type) === 'polling') {
            this.accountSubscriber = new pollingDriftClientAccountSubscriber_1.PollingDriftClientAccountSubscriber(this.program, config.accountSubscription.accountLoader, (_w = config.perpMarketIndexes) !== null && _w !== void 0 ? _w : [], (_x = config.spotMarketIndexes) !== null && _x !== void 0 ? _x : [], (_y = config.oracleInfos) !== null && _y !== void 0 ? _y : [], noMarketsAndOraclesSpecified);
        }
        else {
            this.accountSubscriber = new webSocketDriftClientAccountSubscriber_1.WebSocketDriftClientAccountSubscriber(this.program, (_z = config.perpMarketIndexes) !== null && _z !== void 0 ? _z : [], (_0 = config.spotMarketIndexes) !== null && _0 !== void 0 ? _0 : [], (_1 = config.oracleInfos) !== null && _1 !== void 0 ? _1 : [], noMarketsAndOraclesSpecified, {
                resubTimeoutMs: (_2 = config.accountSubscription) === null || _2 === void 0 ? void 0 : _2.resubTimeoutMs,
                logResubMessages: (_3 = config.accountSubscription) === null || _3 === void 0 ? void 0 : _3.logResubMessages,
            }, (_4 = config.accountSubscription) === null || _4 === void 0 ? void 0 : _4.commitment);
        }
        this.eventEmitter = this.accountSubscriber.eventEmitter;
        if (config.enableMetricsEvents) {
            this.enableMetricsEvents = true;
            this.metricsEventEmitter = new events_1.EventEmitter();
        }
        this.txSender =
            (_5 = config.txSender) !== null && _5 !== void 0 ? _5 : new retryTxSender_1.RetryTxSender({
                connection: this.connection,
                wallet: this.wallet,
                opts: this.opts,
            });
    }
    getUserMapKey(subAccountId, authority) {
        return `${subAccountId}_${authority.toString()}`;
    }
    createUser(subAccountId, accountSubscriptionConfig, authority) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.authority, subAccountId);
        return new user_1.User({
            driftClient: this,
            userAccountPublicKey,
            accountSubscription: accountSubscriptionConfig,
        });
    }
    async subscribe() {
        let subscribePromises = [this.addAndSubscribeToUsers()].concat(this.accountSubscriber.subscribe());
        if (this.userStats !== undefined) {
            subscribePromises = subscribePromises.concat(this.userStats.subscribe());
        }
        this.isSubscribed = (await Promise.all(subscribePromises)).reduce((success, prevSuccess) => success && prevSuccess);
        return this.isSubscribed;
    }
    subscribeUsers() {
        return [...this.users.values()].map((user) => user.subscribe());
    }
    /**
     *	Forces the accountSubscriber to fetch account updates from rpc
     */
    async fetchAccounts() {
        let promises = [...this.users.values()]
            .map((user) => user.fetchAccounts())
            .concat(this.accountSubscriber.fetch());
        if (this.userStats) {
            promises = promises.concat(this.userStats.fetchAccounts());
        }
        await Promise.all(promises);
    }
    async unsubscribe() {
        let unsubscribePromises = this.unsubscribeUsers().concat(this.accountSubscriber.unsubscribe());
        if (this.userStats !== undefined) {
            unsubscribePromises = unsubscribePromises.concat(this.userStats.unsubscribe());
        }
        await Promise.all(unsubscribePromises);
        this.isSubscribed = false;
    }
    unsubscribeUsers() {
        return [...this.users.values()].map((user) => user.unsubscribe());
    }
    async getStatePublicKey() {
        if (this.statePublicKey) {
            return this.statePublicKey;
        }
        this.statePublicKey = await (0, pda_1.getDriftStateAccountPublicKey)(this.program.programId);
        return this.statePublicKey;
    }
    getSignerPublicKey() {
        if (this.signerPublicKey) {
            return this.signerPublicKey;
        }
        this.signerPublicKey = (0, pda_1.getDriftSignerPublicKey)(this.program.programId);
        return this.signerPublicKey;
    }
    getStateAccount() {
        return this.accountSubscriber.getStateAccountAndSlot().data;
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     */
    async forceGetStateAccount() {
        await this.accountSubscriber.fetch();
        return this.accountSubscriber.getStateAccountAndSlot().data;
    }
    getPerpMarketAccount(marketIndex) {
        var _a;
        return (_a = this.accountSubscriber.getMarketAccountAndSlot(marketIndex)) === null || _a === void 0 ? void 0 : _a.data;
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param marketIndex
     */
    async forceGetPerpMarketAccount(marketIndex) {
        var _a, _b;
        await this.accountSubscriber.fetch();
        let data = (_a = this.accountSubscriber.getMarketAccountAndSlot(marketIndex)) === null || _a === void 0 ? void 0 : _a.data;
        let i = 0;
        while (data === undefined && i < 10) {
            await this.accountSubscriber.fetch();
            data = (_b = this.accountSubscriber.getMarketAccountAndSlot(marketIndex)) === null || _b === void 0 ? void 0 : _b.data;
            i++;
        }
        return data;
    }
    getPerpMarketAccounts() {
        return this.accountSubscriber
            .getMarketAccountsAndSlots()
            .filter((value) => value !== undefined)
            .map((value) => value.data);
    }
    getSpotMarketAccount(marketIndex) {
        return this.accountSubscriber.getSpotMarketAccountAndSlot(marketIndex).data;
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param marketIndex
     */
    async forceGetSpotMarketAccount(marketIndex) {
        await this.accountSubscriber.fetch();
        return this.accountSubscriber.getSpotMarketAccountAndSlot(marketIndex).data;
    }
    getSpotMarketAccounts() {
        return this.accountSubscriber
            .getSpotMarketAccountsAndSlots()
            .filter((value) => value !== undefined)
            .map((value) => value.data);
    }
    getQuoteSpotMarketAccount() {
        return this.accountSubscriber.getSpotMarketAccountAndSlot(numericConstants_1.QUOTE_SPOT_MARKET_INDEX).data;
    }
    getOraclePriceDataAndSlot(oraclePublicKey) {
        return this.accountSubscriber.getOraclePriceDataAndSlot(oraclePublicKey);
    }
    async getSerumV3FulfillmentConfig(serumMarket) {
        const address = await (0, pda_1.getSerumFulfillmentConfigPublicKey)(this.program.programId, serumMarket);
        return (await this.program.account.serumV3FulfillmentConfig.fetch(address));
    }
    async getPhoenixV1FulfillmentConfig(phoenixMarket) {
        const address = await (0, pda_1.getPhoenixFulfillmentConfigPublicKey)(this.program.programId, phoenixMarket);
        return (await this.program.account.phoenixV1FulfillmentConfig.fetch(address));
    }
    async fetchMarketLookupTableAccount() {
        if (this.lookupTableAccount)
            return this.lookupTableAccount;
        if (!this.marketLookupTable) {
            console.log('Market lookup table address not set');
            return;
        }
        const lookupTableAccount = (await this.connection.getAddressLookupTable(this.marketLookupTable)).value;
        this.lookupTableAccount = lookupTableAccount;
        return lookupTableAccount;
    }
    /**
     * Update the wallet to use for drift transactions and linked user account
     * @param newWallet
     * @param subAccountIds
     * @param activeSubAccountId
     * @param includeDelegates
     */
    async updateWallet(newWallet, subAccountIds, activeSubAccountId, includeDelegates, authoritySubaccountMap) {
        var _a, _b, _c;
        const newProvider = new anchor_1.AnchorProvider(this.connection, 
        // @ts-ignore
        newWallet, this.opts);
        const newProgram = new anchor_1.Program(drift_json_1.default, this.program.programId, newProvider);
        this.skipLoadUsers = false;
        // Update provider for txSender with new wallet details
        this.txSender.wallet = newWallet;
        this.wallet = newWallet;
        this.provider = newProvider;
        this.program = newProgram;
        this.authority = newWallet.publicKey;
        this.activeSubAccountId = activeSubAccountId;
        this.userStatsAccountPublicKey = undefined;
        this.includeDelegates = includeDelegates !== null && includeDelegates !== void 0 ? includeDelegates : false;
        const walletSupportsVersionedTxns = 
        //@ts-ignore
        (_b = (_a = this.wallet.supportedTransactionVersions) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0 > 1;
        this.txVersion = walletSupportsVersionedTxns ? 0 : 'legacy';
        if (includeDelegates && subAccountIds) {
            throw new Error('Can only pass one of includeDelegates or subAccountIds. If you want to specify subaccount ids for multiple authorities, pass authoritySubaccountMap instead');
        }
        if (authoritySubaccountMap && subAccountIds) {
            throw new Error('Can only pass one of authoritySubaccountMap or subAccountIds');
        }
        if (authoritySubaccountMap && includeDelegates) {
            throw new Error('Can only pass one of authoritySubaccountMap or includeDelegates');
        }
        this.authoritySubAccountMap = authoritySubaccountMap
            ? authoritySubaccountMap
            : subAccountIds
                ? new Map([[this.authority.toString(), subAccountIds]])
                : new Map();
        /* Reset user stats account */
        if ((_c = this.userStats) === null || _c === void 0 ? void 0 : _c.isSubscribed) {
            await this.userStats.unsubscribe();
        }
        this.userStats = undefined;
        this.userStats = new userStats_1.UserStats({
            driftClient: this,
            userStatsAccountPublicKey: this.getUserStatsAccountPublicKey(),
            accountSubscription: this.userStatsAccountSubscriptionConfig,
        });
        await this.userStats.subscribe();
        let success = true;
        if (this.isSubscribed) {
            await Promise.all(this.unsubscribeUsers());
            this.users.clear();
            success = await this.addAndSubscribeToUsers();
        }
        return success;
    }
    async switchActiveUser(subAccountId, authority) {
        var _a;
        const authorityChanged = authority && !((_a = this.authority) === null || _a === void 0 ? void 0 : _a.equals(authority));
        this.activeSubAccountId = subAccountId;
        this.authority = authority !== null && authority !== void 0 ? authority : this.authority;
        this.userStatsAccountPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.authority);
        /* If changing the user authority ie switching from delegate to non-delegate account, need to re-subscribe to the user stats account */
        if (authorityChanged) {
            if (this.userStats && this.userStats.isSubscribed) {
                await this.userStats.unsubscribe();
            }
            this.userStats = new userStats_1.UserStats({
                driftClient: this,
                userStatsAccountPublicKey: this.userStatsAccountPublicKey,
                accountSubscription: this.userAccountSubscriptionConfig,
            });
            this.userStats.subscribe();
        }
    }
    async addUser(subAccountId, authority, userAccount) {
        authority = authority !== null && authority !== void 0 ? authority : this.authority;
        const userKey = this.getUserMapKey(subAccountId, authority);
        if (this.users.has(userKey) && this.users.get(userKey).isSubscribed) {
            return true;
        }
        const user = this.createUser(subAccountId, this.userAccountSubscriptionConfig, authority);
        const result = await user.subscribe(userAccount);
        if (result) {
            this.users.set(userKey, user);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Adds and subscribes to users based on params set by the constructor or by updateWallet.
     */
    async addAndSubscribeToUsers() {
        var _a, _b, _c, _d, _e, _f, _g;
        // save the rpc calls if driftclient is initialized without a real wallet
        if (this.skipLoadUsers)
            return true;
        let result = true;
        if (this.authoritySubAccountMap && this.authoritySubAccountMap.size > 0) {
            this.authoritySubAccountMap.forEach(async (value, key) => {
                for (const subAccountId of value) {
                    result =
                        result && (await this.addUser(subAccountId, new web3_js_1.PublicKey(key)));
                }
            });
            if (this.activeSubAccountId == undefined) {
                this.switchActiveUser((_a = [...this.authoritySubAccountMap.values()][0][0]) !== null && _a !== void 0 ? _a : 0, new web3_js_1.PublicKey((_b = [...this.authoritySubAccountMap.keys()][0]) !== null && _b !== void 0 ? _b : this.authority.toString()));
            }
        }
        else {
            let userAccounts = [];
            let delegatedAccounts = [];
            const userAccountsPromise = this.getUserAccountsForAuthority(this.wallet.publicKey);
            if (this.includeDelegates) {
                const delegatedAccountsPromise = this.getUserAccountsForDelegate(this.wallet.publicKey);
                [userAccounts, delegatedAccounts] = await Promise.all([
                    userAccountsPromise,
                    delegatedAccountsPromise,
                ]);
                !userAccounts && (userAccounts = []);
                !delegatedAccounts && (delegatedAccounts = []);
            }
            else {
                userAccounts = (_c = (await userAccountsPromise)) !== null && _c !== void 0 ? _c : [];
            }
            const allAccounts = userAccounts.concat(delegatedAccounts);
            const addAllAccountsPromise = allAccounts.map((acc) => this.addUser(acc.subAccountId, acc.authority, acc));
            const addAllAccountsResults = await Promise.all(addAllAccountsPromise);
            result = addAllAccountsResults.every((res) => !!res);
            if (this.activeSubAccountId == undefined) {
                this.switchActiveUser((_e = (_d = userAccounts.concat(delegatedAccounts)[0]) === null || _d === void 0 ? void 0 : _d.subAccountId) !== null && _e !== void 0 ? _e : 0, (_g = (_f = userAccounts.concat(delegatedAccounts)[0]) === null || _f === void 0 ? void 0 : _f.authority) !== null && _g !== void 0 ? _g : this.authority);
            }
        }
        return result;
    }
    async getProcessedTransactionParams(txParams, txParamProcessingParams) {
        const tx = await txParamProcessor_1.TransactionProcessor.process({
            txProps: {
                instructions: txParams.instructions,
                txParams: txParams.txParams,
                txVersion: txParams.txVersion,
                lookupTables: txParams.lookupTables,
            },
            txBuilder: (updatedTxParams) => this.buildTransaction(updatedTxParams.instructions, updatedTxParams === null || updatedTxParams === void 0 ? void 0 : updatedTxParams.txParams, updatedTxParams.txVersion, updatedTxParams.lookupTables, true),
            processConfig: txParamProcessingParams,
            processParams: {
                connection: this.connection,
            },
        });
        return tx;
    }
    async initializeUserAccount(subAccountId = 0, name, referrerInfo, txParams) {
        const initializeIxs = [];
        const [userAccountPublicKey, initializeUserAccountIx] = await this.getInitializeUserInstructions(subAccountId, name, referrerInfo);
        if (subAccountId === 0) {
            if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
                initializeIxs.push(await this.getInitializeUserStatsIx());
            }
        }
        initializeIxs.push(initializeUserAccountIx);
        const tx = await this.buildTransaction(initializeIxs, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        await this.addUser(subAccountId);
        return [txSig, userAccountPublicKey];
    }
    async getInitializeUserInstructions(subAccountId = 0, name, referrerInfo) {
        const userAccountPublicKey = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, subAccountId);
        const remainingAccounts = new Array();
        if (referrerInfo !== undefined) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const state = this.getStateAccount();
        if (!state.whitelistMint.equals(web3_js_1.PublicKey.default)) {
            const associatedTokenPublicKey = await (0, spl_token_1.getAssociatedTokenAddress)(state.whitelistMint, this.wallet.publicKey);
            remainingAccounts.push({
                pubkey: associatedTokenPublicKey,
                isWritable: false,
                isSigner: false,
            });
        }
        if (name === undefined) {
            if (subAccountId === 0) {
                name = userName_1.DEFAULT_USER_NAME;
            }
            else {
                name = `Subaccount ${subAccountId + 1}`;
            }
        }
        const nameBuffer = (0, userName_1.encodeName)(name);
        const initializeUserAccountIx = await this.program.instruction.initializeUser(subAccountId, nameBuffer, {
            accounts: {
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
                state: await this.getStatePublicKey(),
            },
            remainingAccounts,
        });
        return [userAccountPublicKey, initializeUserAccountIx];
    }
    async getInitializeUserStatsIx() {
        return await this.program.instruction.initializeUserStats({
            accounts: {
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
                state: await this.getStatePublicKey(),
            },
        });
    }
    async getNextSubAccountId() {
        const userStats = this.getUserStats();
        let userStatsAccount;
        if (!userStats) {
            userStatsAccount = await (0, fetch_1.fetchUserStatsAccount)(this.connection, this.program, this.wallet.publicKey);
        }
        else {
            userStatsAccount = userStats.getAccount();
        }
        return userStatsAccount.numberOfSubAccountsCreated;
    }
    async initializeReferrerName(name) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, 0);
        const nameBuffer = (0, userName_1.encodeName)(name);
        const referrerNameAccountPublicKey = (0, pda_1.getReferrerNamePublicKeySync)(this.program.programId, nameBuffer);
        const tx = await this.program.transaction.initializeReferrerName(nameBuffer, {
            accounts: {
                referrerName: referrerNameAccountPublicKey,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserName(name, subAccountId = 0) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        const nameBuffer = (0, userName_1.encodeName)(name);
        const tx = await this.program.transaction.updateUserName(subAccountId, nameBuffer, {
            accounts: {
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserCustomMarginRatio(updates, txParams) {
        const ixs = await Promise.all(updates.map(async ({ marginRatio, subAccountId }) => {
            const ix = await this.getUpdateUserCustomMarginRatioIx(marginRatio, subAccountId);
            return ix;
        }));
        const tx = await this.buildTransaction(ixs, txParams !== null && txParams !== void 0 ? txParams : this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserCustomMarginRatioIx(marginRatio, subAccountId = 0) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        await this.addUser(subAccountId, this.wallet.publicKey);
        const ix = this.program.instruction.updateUserCustomMarginRatio(subAccountId, marginRatio, {
            accounts: {
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
        });
        return ix;
    }
    async getUpdateUserMarginTradingEnabledIx(marginTradingEnabled, subAccountId = 0, userAccountPublicKey) {
        const userAccountPublicKeyToUse = userAccountPublicKey ||
            (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        await this.addUser(subAccountId, this.wallet.publicKey);
        let remainingAccounts;
        try {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [this.getUserAccount(subAccountId)],
            });
        }
        catch (err) {
            remainingAccounts = [];
        }
        return await this.program.instruction.updateUserMarginTradingEnabled(subAccountId, marginTradingEnabled, {
            accounts: {
                user: userAccountPublicKeyToUse,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateUserMarginTradingEnabled(updates) {
        const ixs = await Promise.all(updates.map(async ({ marginTradingEnabled, subAccountId }) => {
            return await this.getUpdateUserMarginTradingEnabledIx(marginTradingEnabled, subAccountId);
        }));
        const tx = await this.buildTransaction(ixs, this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserDelegate(delegate, subAccountId = 0) {
        const tx = await this.program.transaction.updateUserDelegate(subAccountId, delegate, {
            accounts: {
                user: await this.getUserAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserAdvancedLp(updates) {
        const ixs = await Promise.all(updates.map(async ({ advancedLp, subAccountId }) => {
            return await this.getUpdateAdvancedDlpIx(advancedLp, subAccountId);
        }));
        const tx = await this.buildTransaction(ixs, this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateAdvancedDlpIx(advancedLp, subAccountId) {
        const ix = await this.program.instruction.updateUserAdvancedLp(subAccountId, advancedLp, {
            accounts: {
                user: (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId),
                authority: this.wallet.publicKey,
            },
        });
        return ix;
    }
    async updateUserReduceOnly(updates) {
        const ixs = await Promise.all(updates.map(async ({ reduceOnly, subAccountId }) => {
            return await this.getUpdateUserReduceOnlyIx(reduceOnly, subAccountId);
        }));
        const tx = await this.buildTransaction(ixs, this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserReduceOnlyIx(reduceOnly, subAccountId) {
        const ix = await this.program.instruction.updateUserReduceOnly(subAccountId, reduceOnly, {
            accounts: {
                user: (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId),
                authority: this.wallet.publicKey,
            },
        });
        return ix;
    }
    async fetchAllUserAccounts(includeIdle = true) {
        let filters = undefined;
        if (!includeIdle) {
            filters = [(0, memcmp_1.getNonIdleUserFilter)()];
        }
        return (await this.program.account.user.all(filters));
    }
    async getUserAccountsForDelegate(delegate) {
        const programAccounts = await this.program.account.user.all([
            {
                memcmp: {
                    offset: 40,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(delegate.toBuffer()),
                },
            },
        ]);
        return programAccounts
            .map((programAccount) => programAccount.account)
            .sort((a, b) => a.subAccountId - b.subAccountId);
    }
    async getUserAccountsAndAddressesForAuthority(authority) {
        const programAccounts = await this.program.account.user.all([
            {
                memcmp: {
                    offset: 8,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(authority.toBuffer()),
                },
            },
        ]);
        return programAccounts.map((programAccount) => programAccount);
    }
    async getUserAccountsForAuthority(authority) {
        const programAccounts = await this.program.account.user.all([
            {
                memcmp: {
                    offset: 8,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(authority.toBuffer()),
                },
            },
        ]);
        return programAccounts
            .map((programAccount) => programAccount.account)
            .sort((a, b) => a.subAccountId - b.subAccountId);
    }
    async getReferredUserStatsAccountsByReferrer(referrer) {
        const programAccounts = await this.program.account.userStats.all([
            {
                memcmp: {
                    offset: 40,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(referrer.toBuffer()),
                },
            },
        ]);
        return programAccounts.map((programAccount) => programAccount.account);
    }
    async getReferrerNameAccountsForAuthority(authority) {
        const programAccounts = await this.program.account.referrerName.all([
            {
                memcmp: {
                    offset: 8,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(authority.toBuffer()),
                },
            },
        ]);
        return programAccounts.map((programAccount) => programAccount.account);
    }
    async deleteUser(subAccountId = 0, txParams) {
        var _a;
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        const ix = await this.getUserDeletionIx(userAccountPublicKey);
        const { txSig } = await this.sendTransaction(await this.buildTransaction(ix, txParams), [], this.opts);
        const userMapKey = this.getUserMapKey(subAccountId, this.wallet.publicKey);
        await ((_a = this.users.get(userMapKey)) === null || _a === void 0 ? void 0 : _a.unsubscribe());
        this.users.delete(userMapKey);
        return txSig;
    }
    async getUserDeletionIx(userAccountPublicKey) {
        const ix = await this.program.instruction.deleteUser({
            accounts: {
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                state: await this.getStatePublicKey(),
            },
        });
        return ix;
    }
    async reclaimRent(subAccountId = 0, txParams) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        const ix = await this.getReclaimRentIx(userAccountPublicKey);
        const { txSig } = await this.sendTransaction(await this.buildTransaction(ix, txParams), [], this.opts);
        return txSig;
    }
    async getReclaimRentIx(userAccountPublicKey) {
        return await this.program.instruction.reclaimRent({
            accounts: {
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                state: await this.getStatePublicKey(),
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
            },
        });
    }
    getUser(subAccountId, authority) {
        subAccountId = subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId;
        authority = authority !== null && authority !== void 0 ? authority : this.authority;
        const userMapKey = this.getUserMapKey(subAccountId, authority);
        if (!this.users.has(userMapKey)) {
            throw new Error(`DriftClient has no user for user id ${userMapKey}`);
        }
        return this.users.get(userMapKey);
    }
    hasUser(subAccountId, authority) {
        subAccountId = subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId;
        authority = authority !== null && authority !== void 0 ? authority : this.authority;
        const userMapKey = this.getUserMapKey(subAccountId, authority);
        return this.users.has(userMapKey);
    }
    getUsers() {
        // delegate users get added to the end
        return [...this.users.values()]
            .filter((acct) => acct.getUserAccount().authority.equals(this.wallet.publicKey))
            .concat([...this.users.values()].filter((acct) => !acct.getUserAccount().authority.equals(this.wallet.publicKey)));
    }
    getUserStats() {
        return this.userStats;
    }
    async fetchReferrerNameAccount(name) {
        const nameBuffer = (0, userName_1.encodeName)(name);
        const referrerNameAccountPublicKey = (0, pda_1.getReferrerNamePublicKeySync)(this.program.programId, nameBuffer);
        return (await this.program.account.referrerName.fetch(referrerNameAccountPublicKey));
    }
    getUserStatsAccountPublicKey() {
        if (this.userStatsAccountPublicKey) {
            return this.userStatsAccountPublicKey;
        }
        this.userStatsAccountPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.authority);
        return this.userStatsAccountPublicKey;
    }
    async getUserAccountPublicKey(subAccountId, authority) {
        return this.getUser(subAccountId, authority).userAccountPublicKey;
    }
    getUserAccount(subAccountId, authority) {
        return this.getUser(subAccountId, authority).getUserAccount();
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param subAccountId
     */
    async forceGetUserAccount(subAccountId) {
        await this.getUser(subAccountId).fetchAccounts();
        return this.getUser(subAccountId).getUserAccount();
    }
    getUserAccountAndSlot(subAccountId) {
        return this.getUser(subAccountId).getUserAccountAndSlot();
    }
    getSpotPosition(marketIndex, subAccountId) {
        return this.getUserAccount(subAccountId).spotPositions.find((spotPosition) => spotPosition.marketIndex === marketIndex);
    }
    getQuoteAssetTokenAmount() {
        return this.getTokenAmount(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
    }
    /**
     * Returns the token amount for a given market. The spot market precision is based on the token mint decimals.
     * Positive if it is a deposit, negative if it is a borrow.
     * @param marketIndex
     */
    getTokenAmount(marketIndex) {
        const spotPosition = this.getSpotPosition(marketIndex);
        if (spotPosition === undefined) {
            return numericConstants_1.ZERO;
        }
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return (0, spotBalance_1.getSignedTokenAmount)((0, spotBalance_1.getTokenAmount)(spotPosition.scaledBalance, spotMarket, spotPosition.balanceType), spotPosition.balanceType);
    }
    /**
     * Converts an amount to the spot precision for a given market. The spot market precision is based on the token mint decimals.
     * @param marketIndex
     * @param amount
     */
    convertToSpotPrecision(marketIndex, amount) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return (0, spotMarket_1.castNumberToSpotPrecision)(amount, spotMarket);
    }
    /**
     * Converts an amount to the perp precision. The perp market precision is {@link BASE_PRECISION} (1e9).
     * @param amount
     */
    convertToPerpPrecision(amount) {
        if (typeof amount === 'number') {
            return (0, utils_2.numberToSafeBN)(amount, numericConstants_1.BASE_PRECISION);
        }
        else {
            return amount.mul(numericConstants_1.BASE_PRECISION);
        }
    }
    /**
     * Converts an amount to the price precision. The perp market precision is {@link PRICE_PRECISION} (1e6).
     * @param amount
     */
    convertToPricePrecision(amount) {
        if (typeof amount === 'number') {
            return (0, utils_2.numberToSafeBN)(amount, numericConstants_1.PRICE_PRECISION);
        }
        else {
            return amount.mul(numericConstants_1.BASE_PRECISION);
        }
    }
    /**
     * Each drift instruction must include perp and sport market accounts in the ix remaining accounts.
     * Use this function to force a subset of markets to be included in the remaining accounts for every ix
     *
     * @param perpMarketIndexes
     * @param spotMarketIndexes
     */
    mustIncludeMarketsInIx({ perpMarketIndexes, spotMarketIndexes, }) {
        perpMarketIndexes.forEach((perpMarketIndex) => {
            this.mustIncludePerpMarketIndexes.add(perpMarketIndex);
        });
        spotMarketIndexes.forEach((spotMarketIndex) => {
            this.mustIncludeSpotMarketIndexes.add(spotMarketIndex);
        });
    }
    getRemainingAccounts(params) {
        var _a;
        const { oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap } = this.getRemainingAccountMapsForUsers(params.userAccounts);
        if (params.useMarketLastSlotCache) {
            const lastUserSlot = (_a = this.getUserAccountAndSlot()) === null || _a === void 0 ? void 0 : _a.slot;
            for (const [marketIndex, slot,] of this.perpMarketLastSlotCache.entries()) {
                // if cache has more recent slot than user positions account slot, add market to remaining accounts
                // otherwise remove from slot
                if (slot > lastUserSlot) {
                    this.addPerpMarketToRemainingAccountMaps(marketIndex, false, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
                }
                else {
                    this.perpMarketLastSlotCache.delete(marketIndex);
                }
            }
            for (const [marketIndex, slot,] of this.spotMarketLastSlotCache.entries()) {
                // if cache has more recent slot than user positions account slot, add market to remaining accounts
                // otherwise remove from slot
                if (slot > lastUserSlot) {
                    this.addSpotMarketToRemainingAccountMaps(marketIndex, false, oracleAccountMap, spotMarketAccountMap);
                }
                else {
                    this.spotMarketLastSlotCache.delete(marketIndex);
                }
            }
        }
        if (params.readablePerpMarketIndex !== undefined) {
            const readablePerpMarketIndexes = Array.isArray(params.readablePerpMarketIndex)
                ? params.readablePerpMarketIndex
                : [params.readablePerpMarketIndex];
            for (const marketIndex of readablePerpMarketIndexes) {
                this.addPerpMarketToRemainingAccountMaps(marketIndex, false, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
            }
        }
        for (const perpMarketIndex of this.mustIncludePerpMarketIndexes.values()) {
            this.addPerpMarketToRemainingAccountMaps(perpMarketIndex, false, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
        }
        if (params.readableSpotMarketIndexes !== undefined) {
            for (const readableSpotMarketIndex of params.readableSpotMarketIndexes) {
                this.addSpotMarketToRemainingAccountMaps(readableSpotMarketIndex, false, oracleAccountMap, spotMarketAccountMap);
            }
        }
        for (const spotMarketIndex of this.mustIncludeSpotMarketIndexes.values()) {
            this.addSpotMarketToRemainingAccountMaps(spotMarketIndex, false, oracleAccountMap, spotMarketAccountMap);
        }
        if (params.writablePerpMarketIndexes !== undefined) {
            for (const writablePerpMarketIndex of params.writablePerpMarketIndexes) {
                this.addPerpMarketToRemainingAccountMaps(writablePerpMarketIndex, true, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
            }
        }
        if (params.writableSpotMarketIndexes !== undefined) {
            for (const writableSpotMarketIndex of params.writableSpotMarketIndexes) {
                this.addSpotMarketToRemainingAccountMaps(writableSpotMarketIndex, true, oracleAccountMap, spotMarketAccountMap);
            }
        }
        return [
            ...oracleAccountMap.values(),
            ...spotMarketAccountMap.values(),
            ...perpMarketAccountMap.values(),
        ];
    }
    addPerpMarketToRemainingAccountMaps(marketIndex, writable, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap) {
        const perpMarketAccount = this.getPerpMarketAccount(marketIndex);
        perpMarketAccountMap.set(marketIndex, {
            pubkey: perpMarketAccount.pubkey,
            isSigner: false,
            isWritable: writable,
        });
        const oracleWritable = writable && (0, types_1.isVariant)(perpMarketAccount.amm.oracleSource, 'prelaunch');
        oracleAccountMap.set(perpMarketAccount.amm.oracle.toString(), {
            pubkey: perpMarketAccount.amm.oracle,
            isSigner: false,
            isWritable: oracleWritable,
        });
        this.addSpotMarketToRemainingAccountMaps(perpMarketAccount.quoteSpotMarketIndex, false, oracleAccountMap, spotMarketAccountMap);
    }
    addSpotMarketToRemainingAccountMaps(marketIndex, writable, oracleAccountMap, spotMarketAccountMap) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        spotMarketAccountMap.set(spotMarketAccount.marketIndex, {
            pubkey: spotMarketAccount.pubkey,
            isSigner: false,
            isWritable: writable,
        });
        if (!spotMarketAccount.oracle.equals(web3_js_1.PublicKey.default)) {
            oracleAccountMap.set(spotMarketAccount.oracle.toString(), {
                pubkey: spotMarketAccount.oracle,
                isSigner: false,
                isWritable: false,
            });
        }
    }
    getRemainingAccountMapsForUsers(userAccounts) {
        const oracleAccountMap = new Map();
        const spotMarketAccountMap = new Map();
        const perpMarketAccountMap = new Map();
        for (const userAccount of userAccounts) {
            for (const spotPosition of userAccount.spotPositions) {
                if (!(0, spotPosition_1.isSpotPositionAvailable)(spotPosition)) {
                    this.addSpotMarketToRemainingAccountMaps(spotPosition.marketIndex, false, oracleAccountMap, spotMarketAccountMap);
                    if (!spotPosition.openAsks.eq(numericConstants_1.ZERO) ||
                        !spotPosition.openBids.eq(numericConstants_1.ZERO)) {
                        this.addSpotMarketToRemainingAccountMaps(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, false, oracleAccountMap, spotMarketAccountMap);
                    }
                }
            }
            for (const position of userAccount.perpPositions) {
                if (!(0, position_1.positionIsAvailable)(position)) {
                    this.addPerpMarketToRemainingAccountMaps(position.marketIndex, false, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
                }
            }
        }
        return {
            oracleAccountMap,
            spotMarketAccountMap,
            perpMarketAccountMap,
        };
    }
    getOrder(orderId, subAccountId) {
        var _a;
        return (_a = this.getUserAccount(subAccountId)) === null || _a === void 0 ? void 0 : _a.orders.find((order) => order.orderId === orderId);
    }
    getOrderByUserId(userOrderId, subAccountId) {
        var _a;
        return (_a = this.getUserAccount(subAccountId)) === null || _a === void 0 ? void 0 : _a.orders.find((order) => order.userOrderId === userOrderId);
    }
    /**
     * Get the associated token address for the given spot market
     * @param marketIndex
     * @param useNative
     */
    async getAssociatedTokenAccount(marketIndex, useNative = true) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        if (useNative && spotMarket.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT)) {
            return this.wallet.publicKey;
        }
        const mint = spotMarket.mint;
        return await (0, spl_token_1.getAssociatedTokenAddress)(mint, this.wallet.publicKey);
    }
    createAssociatedTokenAccountIdempotentInstruction(account, payer, owner, mint) {
        return new web3_js_1.TransactionInstruction({
            keys: [
                { pubkey: payer, isSigner: true, isWritable: true },
                { pubkey: account, isSigner: false, isWritable: true },
                { pubkey: owner, isSigner: false, isWritable: false },
                { pubkey: mint, isSigner: false, isWritable: false },
                {
                    pubkey: anchor.web3.SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            ],
            programId: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID,
            data: Buffer.from([0x1]),
        });
    }
    /**
     * Deposit funds into the given spot market
     *
     * @param amount to deposit
     * @param marketIndex spot market index to deposit into
     * @param associatedTokenAccount can be the wallet public key if using native sol
     * @param subAccountId subaccountId to deposit
     * @param reduceOnly if true, deposit must not increase account risk
     */
    async deposit(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly = false, txParams) {
        const additionalSigners = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const signerAuthority = this.wallet.publicKey;
        const createWSOLTokenAccount = isSolMarket && associatedTokenAccount.equals(signerAuthority);
        const instructions = [];
        if (createWSOLTokenAccount) {
            const { ixs, pubkey } = await this.getWrappedSolAccountCreationIxs(amount, true);
            associatedTokenAccount = pubkey;
            instructions.push(...ixs);
        }
        const depositCollateralIx = await this.getDepositInstruction(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly, true);
        instructions.push(depositCollateralIx);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            instructions.push((0, spl_token_1.createCloseAccountInstruction)(associatedTokenAccount, signerAuthority, signerAuthority, []));
        }
        txParams = { ...(txParams !== null && txParams !== void 0 ? txParams : this.txParams), computeUnits: 600000 };
        const tx = await this.buildTransaction(instructions, txParams);
        const { txSig, slot } = await this.sendTransaction(tx, additionalSigners, this.opts);
        this.spotMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getDepositInstruction(amount, marketIndex, userTokenAccount, subAccountId, reduceOnly = false, userInitialized = true) {
        const userAccountPublicKey = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.authority, subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId);
        let remainingAccounts = [];
        if (userInitialized) {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [await this.forceGetUserAccount()],
                useMarketLastSlotCache: true,
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        else {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [],
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        return await this.program.instruction.deposit(marketIndex, amount, reduceOnly, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                spotMarketVault: spotMarketAccount.vault,
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                userTokenAccount: userTokenAccount,
                authority: this.wallet.publicKey,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts,
        });
    }
    async checkIfAccountExists(account) {
        try {
            const accountInfo = await this.connection.getAccountInfo(account);
            return accountInfo != null;
        }
        catch (e) {
            // Doesn't already exist
            return false;
        }
    }
    async getWrappedSolAccountCreationIxs(amount, includeRent) {
        const authority = this.wallet.publicKey;
        // Generate a random seed for wrappedSolAccount.
        const seed = web3_js_1.Keypair.generate().publicKey.toBase58().slice(0, 32);
        // Calculate a publicKey that will be controlled by the authority.
        const wrappedSolAccount = await web3_js_1.PublicKey.createWithSeed(authority, seed, spl_token_1.TOKEN_PROGRAM_ID);
        const result = {
            ixs: [],
            signers: [],
            pubkey: wrappedSolAccount,
        };
        const rentSpaceLamports = new anchor_1.BN(web3_js_1.LAMPORTS_PER_SOL / 100);
        const lamports = includeRent
            ? amount.add(rentSpaceLamports)
            : rentSpaceLamports;
        result.ixs.push(web3_js_1.SystemProgram.createAccountWithSeed({
            fromPubkey: authority,
            basePubkey: authority,
            seed,
            newAccountPubkey: wrappedSolAccount,
            lamports: lamports.toNumber(),
            space: 165,
            programId: spl_token_1.TOKEN_PROGRAM_ID,
        }));
        result.ixs.push((0, spl_token_1.createInitializeAccountInstruction)(wrappedSolAccount, spotMarkets_1.WRAPPED_SOL_MINT, authority));
        return result;
    }
    getAssociatedTokenAccountCreationIx(tokenMintAddress, associatedTokenAddress) {
        return (0, spl_token_1.createAssociatedTokenAccountInstruction)(this.wallet.publicKey, associatedTokenAddress, this.wallet.publicKey, tokenMintAddress);
    }
    /**
     * Creates the User account for a user, and deposits some initial collateral
     * @param amount
     * @param userTokenAccount
     * @param marketIndex
     * @param subAccountId
     * @param name
     * @param fromSubAccountId
     * @param referrerInfo
     * @param donateAmount
     * @param txParams
     * @returns
     */
    async initializeUserAccountAndDepositCollateral(amount, userTokenAccount, marketIndex = 0, subAccountId = 0, name, fromSubAccountId, referrerInfo, donateAmount, txParams, customMaxMarginRatio) {
        const ixs = [];
        const [userAccountPublicKey, initializeUserAccountIx] = await this.getInitializeUserInstructions(subAccountId, name, referrerInfo);
        const additionalSigners = [];
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarket.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const authority = this.wallet.publicKey;
        const isFromSubaccount = fromSubAccountId !== null &&
            fromSubAccountId !== undefined &&
            !isNaN(fromSubAccountId);
        donateAmount = donateAmount ? donateAmount : numericConstants_1.ZERO;
        const createWSOLTokenAccount = (isSolMarket &&
            userTokenAccount.equals(authority) &&
            !isFromSubaccount) ||
            !donateAmount.eq(numericConstants_1.ZERO);
        const wSolAmount = isSolMarket ? amount.add(donateAmount) : donateAmount;
        let wsolTokenAccount;
        if (createWSOLTokenAccount) {
            const { ixs: startIxs, pubkey } = await this.getWrappedSolAccountCreationIxs(wSolAmount, true);
            wsolTokenAccount = pubkey;
            if (isSolMarket) {
                userTokenAccount = pubkey;
            }
            ixs.push(...startIxs);
        }
        const depositCollateralIx = isFromSubaccount
            ? await this.getTransferDepositIx(amount, marketIndex, fromSubAccountId, subAccountId)
            : await this.getDepositInstruction(amount, marketIndex, userTokenAccount, subAccountId, false, false);
        if (subAccountId === 0) {
            if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
                ixs.push(await this.getInitializeUserStatsIx());
            }
        }
        ixs.push(initializeUserAccountIx, depositCollateralIx);
        if (!donateAmount.eq(numericConstants_1.ZERO)) {
            const donateIx = await this.getDepositIntoSpotMarketRevenuePoolIx(1, donateAmount, wsolTokenAccount);
            ixs.push(donateIx);
        }
        // Set the max margin ratio to initialize account with if passed
        if (customMaxMarginRatio) {
            const customMarginRatioIx = await this.getUpdateUserCustomMarginRatioIx(customMaxMarginRatio, subAccountId);
            ixs.push(customMarginRatioIx);
        }
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            ixs.push((0, spl_token_1.createCloseAccountInstruction)(wsolTokenAccount, authority, authority, []));
        }
        const tx = await this.buildTransaction(ixs, txParams);
        const { txSig, slot } = await this.sendTransaction(tx, additionalSigners, this.opts);
        this.spotMarketLastSlotCache.set(marketIndex, slot);
        await this.addUser(subAccountId);
        return [txSig, userAccountPublicKey];
    }
    async initializeUserAccountForDevnet(subAccountId = 0, name = userName_1.DEFAULT_USER_NAME, marketIndex, tokenFaucet, amount, referrerInfo, txParams) {
        const ixs = [];
        const [associateTokenPublicKey, createAssociatedAccountIx, mintToIx] = await tokenFaucet.createAssociatedTokenAccountAndMintToInstructions(this.wallet.publicKey, amount);
        const [userAccountPublicKey, initializeUserAccountIx] = await this.getInitializeUserInstructions(subAccountId, name, referrerInfo);
        const depositCollateralIx = await this.getDepositInstruction(amount, marketIndex, associateTokenPublicKey, subAccountId, false, false);
        ixs.push(createAssociatedAccountIx, mintToIx);
        if (subAccountId === 0) {
            if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
                ixs.push(await this.getInitializeUserStatsIx());
            }
        }
        ixs.push(initializeUserAccountIx, depositCollateralIx);
        const tx = await this.buildTransaction(ixs, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        await this.addUser(subAccountId);
        return [txSig, userAccountPublicKey];
    }
    async getWithdrawalIxs(amount, marketIndex, associatedTokenAddress, reduceOnly = false, subAccountId) {
        const withdrawIxs = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const authority = this.wallet.publicKey;
        const createWSOLTokenAccount = isSolMarket && associatedTokenAddress.equals(authority);
        if (createWSOLTokenAccount) {
            const { ixs, pubkey } = await this.getWrappedSolAccountCreationIxs(amount, false);
            associatedTokenAddress = pubkey;
            withdrawIxs.push(...ixs);
        }
        else {
            const accountExists = await this.checkIfAccountExists(associatedTokenAddress);
            if (!accountExists) {
                const createAssociatedTokenAccountIx = this.getAssociatedTokenAccountCreationIx(spotMarketAccount.mint, associatedTokenAddress);
                withdrawIxs.push(createAssociatedTokenAccountIx);
            }
        }
        const withdrawCollateralIx = await this.getWithdrawIx(amount, spotMarketAccount.marketIndex, associatedTokenAddress, reduceOnly, subAccountId);
        withdrawIxs.push(withdrawCollateralIx);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            withdrawIxs.push((0, spl_token_1.createCloseAccountInstruction)(associatedTokenAddress, authority, authority, []));
        }
        return withdrawIxs;
    }
    /**
     * Withdraws from a user account. If deposit doesn't already exist, creates a borrow
     * @param amount
     * @param marketIndex
     * @param associatedTokenAddress - the token account to withdraw to. can be the wallet public key if using native sol
     * @param reduceOnly
     */
    async withdraw(amount, marketIndex, associatedTokenAddress, reduceOnly = false, subAccountId, txParams) {
        const additionalSigners = [];
        const withdrawIxs = await this.getWithdrawalIxs(amount, marketIndex, associatedTokenAddress, reduceOnly, subAccountId);
        const tx = await this.buildTransaction(withdrawIxs, txParams !== null && txParams !== void 0 ? txParams : this.txParams);
        const { txSig, slot } = await this.sendTransaction(tx, additionalSigners, this.opts);
        this.spotMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async withdrawAllDustPositions(subAccountId, txParams, opts) {
        var _a, _b;
        const user = this.getUser(subAccountId);
        const dustPositionSpotMarketAccounts = user.getSpotMarketAccountsWithDustPosition();
        if (!dustPositionSpotMarketAccounts ||
            dustPositionSpotMarketAccounts.length === 0) {
            (_a = opts === null || opts === void 0 ? void 0 : opts.dustPositionCountCallback) === null || _a === void 0 ? void 0 : _a.call(opts, 0);
            return undefined;
        }
        (_b = opts === null || opts === void 0 ? void 0 : opts.dustPositionCountCallback) === null || _b === void 0 ? void 0 : _b.call(opts, dustPositionSpotMarketAccounts.length);
        let allWithdrawIxs = [];
        for (const position of dustPositionSpotMarketAccounts) {
            const tokenAccount = await (0, spl_token_1.getAssociatedTokenAddress)(position.mint, this.wallet.publicKey);
            const tokenAmount = await user.getTokenAmount(position.marketIndex);
            const withdrawIxs = await this.getWithdrawalIxs(tokenAmount.muln(2), //  2x to ensure all dust is withdrawn
            position.marketIndex, tokenAccount, true, // reduce-only true to ensure all dust is withdrawn
            subAccountId);
            allWithdrawIxs = allWithdrawIxs.concat(withdrawIxs);
        }
        const tx = await this.buildTransaction(allWithdrawIxs, txParams !== null && txParams !== void 0 ? txParams : this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getWithdrawIx(amount, marketIndex, userTokenAccount, reduceOnly = false, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [marketIndex],
            readableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        return await this.program.instruction.withdraw(marketIndex, amount, reduceOnly, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                spotMarketVault: spotMarketAccount.vault,
                driftSigner: this.getSignerPublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                userTokenAccount: userTokenAccount,
                authority: this.wallet.publicKey,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts,
        });
    }
    /**
     * Withdraws from the fromSubAccount and deposits into the toSubAccount
     * @param amount
     * @param marketIndex
     * @param fromSubAccountId
     * @param toSubAccountId
     * @param txParams
     */
    async transferDeposit(amount, marketIndex, fromSubAccountId, toSubAccountId, txParams) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getTransferDepositIx(amount, marketIndex, fromSubAccountId, toSubAccountId), txParams), [], this.opts);
        if (fromSubAccountId === this.activeSubAccountId ||
            toSubAccountId === this.activeSubAccountId) {
            this.spotMarketLastSlotCache.set(marketIndex, slot);
        }
        return txSig;
    }
    async getTransferDepositIx(amount, marketIndex, fromSubAccountId, toSubAccountId) {
        const fromUser = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, fromSubAccountId);
        const toUser = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, toSubAccountId);
        let remainingAccounts;
        const userMapKey = this.getUserMapKey(fromSubAccountId, this.wallet.publicKey);
        if (this.users.has(userMapKey)) {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [this.users.get(userMapKey).getUserAccount()],
                useMarketLastSlotCache: true,
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        else {
            const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.authority, fromSubAccountId);
            const fromUserAccount = (await this.program.account.user.fetch(userAccountPublicKey));
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [fromUserAccount],
                useMarketLastSlotCache: true,
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        return await this.program.instruction.transferDeposit(marketIndex, amount, {
            accounts: {
                authority: this.wallet.publicKey,
                fromUser,
                toUser,
                userStats: this.getUserStatsAccountPublicKey(),
                state: await this.getStatePublicKey(),
                spotMarketVault: this.getSpotMarketAccount(marketIndex).vault,
            },
            remainingAccounts,
        });
    }
    async updateSpotMarketCumulativeInterest(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.updateSpotMarketCumulativeInterestIx(marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async updateSpotMarketCumulativeInterestIx(marketIndex) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return await this.program.instruction.updateSpotMarketCumulativeInterest({
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                spotMarketVault: spotMarket.vault,
                oracle: spotMarket.oracle,
            },
        });
    }
    async settleLP(settleeUserAccountPublicKey, marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.settleLPIx(settleeUserAccountPublicKey, marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async settleLPIx(settleeUserAccountPublicKey, marketIndex) {
        const settleeUserAccount = (await this.program.account.user.fetch(settleeUserAccountPublicKey));
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [settleeUserAccount],
            writablePerpMarketIndexes: [marketIndex],
        });
        return this.program.instruction.settleLp(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: settleeUserAccountPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async removePerpLpShares(marketIndex, sharesToBurn, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getRemovePerpLpSharesIx(marketIndex, sharesToBurn, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async removePerpLpSharesInExpiringMarket(marketIndex, userAccountPublicKey, sharesToBurn, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getRemovePerpLpSharesInExpiringMarket(marketIndex, userAccountPublicKey, sharesToBurn), txParams), [], this.opts);
        return txSig;
    }
    async getRemovePerpLpSharesInExpiringMarket(marketIndex, userAccountPublicKey, sharesToBurn) {
        const userAccount = (await this.program.account.user.fetch(userAccountPublicKey));
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        if (sharesToBurn == undefined) {
            const perpPosition = userAccount.perpPositions.filter((position) => position.marketIndex === marketIndex)[0];
            sharesToBurn = perpPosition.lpShares;
            console.log('burning lp shares:', sharesToBurn.toString());
        }
        return this.program.instruction.removePerpLpSharesInExpiringMarket(sharesToBurn, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async getRemovePerpLpSharesIx(marketIndex, sharesToBurn, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        if (sharesToBurn == undefined) {
            const userAccount = this.getUserAccount(subAccountId);
            const perpPosition = userAccount.perpPositions.filter((position) => position.marketIndex === marketIndex)[0];
            sharesToBurn = perpPosition.lpShares;
            console.log('burning lp shares:', sharesToBurn.toString());
        }
        return this.program.instruction.removePerpLpShares(sharesToBurn, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async addPerpLpShares(amount, marketIndex, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getAddPerpLpSharesIx(amount, marketIndex, subAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getAddPerpLpSharesIx(amount, marketIndex, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        return this.program.instruction.addPerpLpShares(amount, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    getQuoteValuePerLpShare(marketIndex) {
        const perpMarketAccount = this.getPerpMarketAccount(marketIndex);
        const openBids = anchor_1.BN.max(perpMarketAccount.amm.baseAssetReserve.sub(perpMarketAccount.amm.minBaseAssetReserve), numericConstants_1.ZERO);
        const openAsks = anchor_1.BN.max(perpMarketAccount.amm.maxBaseAssetReserve.sub(perpMarketAccount.amm.baseAssetReserve), numericConstants_1.ZERO);
        const oraclePriceData = this.getOracleDataForPerpMarket(marketIndex);
        const maxOpenBidsAsks = anchor_1.BN.max(openBids, openAsks);
        const quoteValuePerLpShare = maxOpenBidsAsks
            .mul(oraclePriceData.price)
            .mul(numericConstants_1.QUOTE_PRECISION)
            .div(numericConstants_1.PRICE_PRECISION)
            .div(perpMarketAccount.amm.sqrtK);
        return quoteValuePerLpShare;
    }
    /**
     * @deprecated use {@link placePerpOrder} or {@link placeAndTakePerpOrder} instead
     */
    async openPosition(direction, amount, marketIndex, limitPrice, subAccountId) {
        return await this.placeAndTakePerpOrder({
            orderType: types_1.OrderType.MARKET,
            marketIndex,
            direction,
            baseAssetAmount: amount,
            price: limitPrice,
        }, undefined, undefined, undefined, subAccountId);
    }
    async sendSignedTx(tx) {
        const { txSig } = await this.sendTransaction(tx, undefined, this.opts, true);
        return txSig;
    }
    /**
     * Sends a market order and returns a signed tx which can fill the order against the vamm, which the caller can use to fill their own order if required.
     * @param orderParams
     * @param userAccountPublicKey
     * @param userAccount
     * @param makerInfo
     * @param txParams
     * @param bracketOrdersParams
     * @param cancelExistingOrders - Builds and returns an extra transaciton to cancel the existing orders in the same perp market. Intended use is to auto-cancel TP/SL orders when closing a position. Ignored if orderParams.marketType is not MarketType.PERP
     * @returns
     */
    async sendMarketOrderAndGetSignedFillTx(orderParams, userAccountPublicKey, userAccount, makerInfo, txParams, bracketOrdersParams = new Array(), referrerInfo, cancelExistingOrders, settlePnl) {
        const marketIndex = orderParams.marketIndex;
        const orderId = userAccount.nextOrderId;
        const ordersIx = await this.getPlaceOrdersIx([orderParams, ...bracketOrdersParams], userAccount.subAccountId);
        /* Cancel open orders in market if requested */
        let cancelExistingOrdersTx;
        if (cancelExistingOrders && (0, types_1.isVariant)(orderParams.marketType, 'perp')) {
            const cancelOrdersIx = await this.getCancelOrdersIx(orderParams.marketType, orderParams.marketIndex, null, userAccount.subAccountId);
            //@ts-ignore
            cancelExistingOrdersTx = await this.buildTransaction([cancelOrdersIx], txParams, this.txVersion);
        }
        /* Settle PnL after fill if requested */
        let settlePnlTx;
        if (settlePnl && (0, types_1.isVariant)(orderParams.marketType, 'perp')) {
            const settlePnlIx = await this.settlePNLIx(userAccountPublicKey, userAccount, marketIndex);
            //@ts-ignore
            settlePnlTx = await this.buildTransaction([settlePnlIx], txParams, this.txVersion);
        }
        // use versioned transactions if there is a lookup table account and wallet is compatible
        if (this.txVersion === 0) {
            const versionedMarketOrderTx = await this.buildTransaction(ordersIx, txParams, 0);
            const fillPerpOrderIx = await this.getFillPerpOrderIx(userAccountPublicKey, userAccount, {
                orderId,
                marketIndex,
            }, makerInfo, referrerInfo, userAccount.subAccountId);
            const versionedFillTx = await this.buildTransaction([fillPerpOrderIx], txParams, 0);
            const allPossibleTxs = [
                versionedMarketOrderTx,
                versionedFillTx,
                cancelExistingOrdersTx,
                settlePnlTx,
            ];
            const txKeys = [
                'signedVersionedMarketOrderTx',
                'signedVersionedFillTx',
                'signedCancelExistingOrdersTx',
                'signedSettlePnlTx',
            ];
            const { signedVersionedMarketOrderTx, signedVersionedFillTx, signedCancelExistingOrdersTx, signedSettlePnlTx, } = await (0, utils_1.getSignedTransactionMap)(
            //@ts-ignore
            this.provider.wallet, allPossibleTxs, txKeys);
            const { txSig, slot } = await this.sendTransaction(signedVersionedMarketOrderTx, [], this.opts, true);
            this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
            return {
                txSig,
                // @ts-ignore
                signedFillTx: signedVersionedFillTx,
                // @ts-ignore
                signedCancelExistingOrdersTx,
                // @ts-ignore
                signedSettlePnlTx,
            };
        }
        else {
            const marketOrderTx = (0, utils_1.wrapInTx)(ordersIx, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice);
            // Apply the latest blockhash to the txs so that we can sign before sending them
            const currentBlockHash = (await this.connection.getLatestBlockhash('finalized')).blockhash;
            marketOrderTx.recentBlockhash = currentBlockHash;
            marketOrderTx.feePayer = userAccount.authority;
            if (cancelExistingOrdersTx) {
                cancelExistingOrdersTx.recentBlockhash = currentBlockHash;
                cancelExistingOrdersTx.feePayer = userAccount.authority;
            }
            if (settlePnlTx) {
                settlePnlTx.recentBlockhash = currentBlockHash;
                settlePnlTx.feePayer = userAccount.authority;
            }
            const allPossibleTxs = [
                marketOrderTx,
                cancelExistingOrdersTx,
                settlePnlTx,
            ];
            const txKeys = [
                'signedMarketOrderTx',
                'signedCancelExistingOrdersTx',
                'signedSettlePnlTx',
            ];
            const { signedMarketOrderTx, signedCancelExistingOrdersTx, signedSettlePnlTx, } = await (0, utils_1.getSignedTransactionMap)(
            //@ts-ignore
            this.provider.wallet, allPossibleTxs, txKeys);
            const { txSig, slot } = await this.sendTransaction(signedMarketOrderTx, [], this.opts, true);
            this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
            return {
                txSig,
                signedFillTx: undefined,
                //@ts-ignore
                signedCancelExistingOrdersTx,
                //@ts-ignore
                signedSettlePnlTx,
            };
        }
    }
    async placePerpOrder(orderParams, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlacePerpOrderIx(orderParams, subAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async getPlacePerpOrderIx(orderParams, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.PERP });
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            readablePerpMarketIndex: orderParams.marketIndex,
        });
        return await this.program.instruction.placePerpOrder(orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateAMMs(marketIndexes, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateAMMsIx(marketIndexes), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateAMMsIx(marketIndexes) {
        for (let i = marketIndexes.length; i < 5; i++) {
            marketIndexes.push(100);
        }
        const marketAccountInfos = [];
        const oracleAccountInfos = [];
        for (const marketIndex of marketIndexes) {
            if (marketIndex !== 100) {
                const market = this.getPerpMarketAccount(marketIndex);
                marketAccountInfos.push({
                    pubkey: market.pubkey,
                    isWritable: true,
                    isSigner: false,
                });
                oracleAccountInfos.push({
                    pubkey: market.amm.oracle,
                    isWritable: false,
                    isSigner: false,
                });
            }
        }
        const remainingAccounts = oracleAccountInfos.concat(marketAccountInfos);
        return await this.program.instruction.updateAmms(marketIndexes, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async settleExpiredMarket(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getSettleExpiredMarketIx(marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getSettleExpiredMarketIx(marketIndex) {
        const marketAccountInfos = [];
        const oracleAccountInfos = [];
        const spotMarketAccountInfos = [];
        const market = this.getPerpMarketAccount(marketIndex);
        marketAccountInfos.push({
            pubkey: market.pubkey,
            isWritable: true,
            isSigner: false,
        });
        oracleAccountInfos.push({
            pubkey: market.amm.oracle,
            isWritable: false,
            isSigner: false,
        });
        spotMarketAccountInfos.push({
            pubkey: this.getSpotMarketAccount(numericConstants_1.QUOTE_SPOT_MARKET_INDEX).pubkey,
            isSigner: false,
            isWritable: true,
        });
        const remainingAccounts = oracleAccountInfos
            .concat(spotMarketAccountInfos)
            .concat(marketAccountInfos);
        return await this.program.instruction.settleExpiredMarket(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async settleExpiredMarketPoolsToRevenuePool(perpMarketIndex, txParams) {
        const perpMarketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, perpMarketIndex);
        const spotMarketPublicKey = await (0, pda_1.getSpotMarketPublicKey)(this.program.programId, numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        const ix = await this.program.instruction.settleExpiredMarketPoolsToRevenuePool({
            accounts: {
                state: await this.getStatePublicKey(),
                admin: this.isSubscribed
                    ? this.getStateAccount().admin
                    : this.wallet.publicKey,
                spotMarket: spotMarketPublicKey,
                perpMarket: perpMarketPublicKey,
            },
        });
        const { txSig } = await this.sendTransaction(await this.buildTransaction(ix, txParams), [], this.opts);
        return txSig;
    }
    async cancelOrder(orderId, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getCancelOrderIx(orderId, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getCancelOrderIx(orderId, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrder(orderId !== null && orderId !== void 0 ? orderId : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async cancelOrderByUserId(userOrderId, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getCancelOrderByUserIdIx(userOrderId, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getCancelOrderByUserIdIx(userOrderId, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const order = this.getOrderByUserId(userOrderId);
        const oracle = this.getPerpMarketAccount(order.marketIndex).amm.oracle;
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrderByUserId(userOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
                oracle,
            },
            remainingAccounts,
        });
    }
    async cancelOrdersByIds(orderIds, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getCancelOrdersByIdsIx(orderIds, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getCancelOrdersByIdsIx(orderIds, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrdersByIds(orderIds, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async cancelOrders(marketType, marketIndex, direction, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getCancelOrdersIx(marketType, marketIndex, direction, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getCancelOrdersIx(marketType, marketIndex, direction, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        let readablePerpMarketIndex = undefined;
        let readableSpotMarketIndexes = undefined;
        if (typeof marketIndex === 'number') {
            if (marketType && (0, types_1.isVariant)(marketType, 'perp')) {
                readablePerpMarketIndex = marketIndex;
            }
            else if (marketType && (0, types_1.isVariant)(marketType, 'spot')) {
                readableSpotMarketIndexes = [marketIndex];
            }
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            readablePerpMarketIndex,
            readableSpotMarketIndexes,
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrders(marketType !== null && marketType !== void 0 ? marketType : null, marketIndex !== null && marketIndex !== void 0 ? marketIndex : null, direction !== null && direction !== void 0 ? direction : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async cancelAndPlaceOrders(cancelOrderParams, placeOrderParams, txParams, subAccountId) {
        const ixs = [
            await this.getCancelOrdersIx(cancelOrderParams.marketType, cancelOrderParams.marketIndex, cancelOrderParams.direction, subAccountId),
            await this.getPlaceOrdersIx(placeOrderParams, subAccountId),
        ];
        const tx = await this.buildTransaction(ixs, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async placeOrders(params, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getPlaceOrdersIx(params, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getPlaceOrdersIx(params, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const readablePerpMarketIndex = [];
        const readableSpotMarketIndexes = [];
        for (const param of params) {
            if (!param.marketType) {
                throw new Error('must set param.marketType');
            }
            if ((0, types_1.isVariant)(param.marketType, 'perp')) {
                readablePerpMarketIndex.push(param.marketIndex);
            }
            else {
                readableSpotMarketIndexes.push(param.marketIndex);
            }
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            readablePerpMarketIndex,
            readableSpotMarketIndexes,
            useMarketLastSlotCache: true,
        });
        const formattedParams = params.map((item) => (0, orderParams_1.getOrderParams)(item));
        return await this.program.instruction.placeOrders(formattedParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async fillPerpOrder(userAccountPublicKey, user, order, makerInfo, referrerInfo, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getFillPerpOrderIx(userAccountPublicKey, user, order, makerInfo, referrerInfo, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getFillPerpOrderIx(userAccountPublicKey, userAccount, order, makerInfo, referrerInfo, fillerSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const filler = await this.getUserAccountPublicKey(fillerSubAccountId);
        const fillerStatsPublicKey = this.getUserStatsAccountPublicKey();
        const marketIndex = order
            ? order.marketIndex
            : userAccount.orders.find((order) => order.orderId === userAccount.nextOrderId - 1).marketIndex;
        makerInfo = Array.isArray(makerInfo)
            ? makerInfo
            : makerInfo
                ? [makerInfo]
                : [];
        const userAccounts = [userAccount];
        for (const maker of makerInfo) {
            userAccounts.push(maker.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writablePerpMarketIndexes: [marketIndex],
        });
        for (const maker of makerInfo) {
            remainingAccounts.push({
                pubkey: maker.maker,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: maker.makerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        if (referrerInfo) {
            const referrerIsMaker = makerInfo.find((maker) => maker.maker.equals(referrerInfo.referrer)) !==
                undefined;
            if (!referrerIsMaker) {
                remainingAccounts.push({
                    pubkey: referrerInfo.referrer,
                    isWritable: true,
                    isSigner: false,
                });
                remainingAccounts.push({
                    pubkey: referrerInfo.referrerStats,
                    isWritable: true,
                    isSigner: false,
                });
            }
        }
        const orderId = order.orderId;
        return await this.program.instruction.fillPerpOrder(orderId, null, {
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                fillerStats: fillerStatsPublicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async getRevertFillIx(fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const fillerStatsPublicKey = this.getUserStatsAccountPublicKey();
        return this.program.instruction.revertFill({
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                fillerStats: fillerStatsPublicKey,
                authority: this.wallet.publicKey,
            },
        });
    }
    async placeSpotOrder(orderParams, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlaceSpotOrderIx(orderParams, subAccountId), txParams), [], this.opts);
        this.spotMarketLastSlotCache.set(orderParams.marketIndex, slot);
        this.spotMarketLastSlotCache.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, slot);
        return txSig;
    }
    async getPlaceSpotOrderIx(orderParams, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.SPOT });
        const userAccountPublicKey = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            readableSpotMarketIndexes: [
                orderParams.marketIndex,
                numericConstants_1.QUOTE_SPOT_MARKET_INDEX,
            ],
        });
        return await this.program.instruction.placeSpotOrder(orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async fillSpotOrder(userAccountPublicKey, user, order, fulfillmentConfig, makerInfo, referrerInfo, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getFillSpotOrderIx(userAccountPublicKey, user, order, fulfillmentConfig, makerInfo, referrerInfo), txParams), [], this.opts);
        return txSig;
    }
    async getFillSpotOrderIx(userAccountPublicKey, userAccount, order, fulfillmentConfig, makerInfo, referrerInfo, fillerPublicKey) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const fillerStatsPublicKey = this.getUserStatsAccountPublicKey();
        const marketIndex = order
            ? order.marketIndex
            : userAccount.orders.find((order) => order.orderId === userAccount.nextOrderId - 1).marketIndex;
        makerInfo = Array.isArray(makerInfo)
            ? makerInfo
            : makerInfo
                ? [makerInfo]
                : [];
        const userAccounts = [userAccount];
        for (const maker of makerInfo) {
            userAccounts.push(maker.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writableSpotMarketIndexes: [marketIndex, numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        for (const maker of makerInfo) {
            remainingAccounts.push({
                pubkey: maker.maker,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: maker.makerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const orderId = order.orderId;
        this.addSpotFulfillmentAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
        return await this.program.instruction.fillSpotOrder(orderId, fulfillmentConfig ? fulfillmentConfig.fulfillmentType : null, null, {
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                fillerStats: fillerStatsPublicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    addSpotFulfillmentAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        if (fulfillmentConfig) {
            if ('serumProgramId' in fulfillmentConfig) {
                this.addSerumRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
            }
            else if ('phoenixProgramId' in fulfillmentConfig) {
                this.addPhoenixRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
            }
            else {
                throw Error('Invalid fulfillment config type');
            }
        }
        else {
            remainingAccounts.push({
                pubkey: this.getSpotMarketAccount(marketIndex).vault,
                isWritable: false,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: this.getQuoteSpotMarketAccount().vault,
                isWritable: false,
                isSigner: false,
            });
        }
    }
    addSerumRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        remainingAccounts.push({
            pubkey: fulfillmentConfig.pubkey,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumProgramId,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumMarket,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumRequestQueue,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumEventQueue,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumBids,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumAsks,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumBaseVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumQuoteVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumOpenOrders,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: (0, pda_1.getSerumSignerPublicKey)(fulfillmentConfig.serumProgramId, fulfillmentConfig.serumMarket, fulfillmentConfig.serumSignerNonce),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSignerPublicKey(),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSpotMarketAccount(marketIndex).vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getQuoteSpotMarketAccount().vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getStateAccount().srmVault,
            isWritable: false,
            isSigner: false,
        });
    }
    addPhoenixRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        remainingAccounts.push({
            pubkey: fulfillmentConfig.pubkey,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixProgramId,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixLogAuthority,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixMarket,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSignerPublicKey(),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixBaseVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixQuoteVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSpotMarketAccount(marketIndex).vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getQuoteSpotMarketAccount().vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isWritable: false,
            isSigner: false,
        });
    }
    /**
     * Swap tokens in drift account using jupiter
     * @param jupiterClient jupiter client to find routes and jupiter instructions
     * @param outMarketIndex the market index of the token you're buying
     * @param inMarketIndex the market index of the token you're selling
     * @param outAssociatedTokenAccount the token account to receive the token being sold on jupiter
     * @param inAssociatedTokenAccount the token account to
     * @param amount the amount of TokenIn, regardless of swapMode
     * @param slippageBps the max slippage passed to jupiter api
     * @param swapMode jupiter swapMode (ExactIn or ExactOut), default is ExactIn
     * @param route the jupiter route to use for the swap
     * @param reduceOnly specify if In or Out token on the drift account must reduceOnly, checked at end of swap
     * @param txParams
     */
    async swap({ jupiterClient, outMarketIndex, inMarketIndex, outAssociatedTokenAccount, inAssociatedTokenAccount, amount, slippageBps, swapMode, route, reduceOnly, txParams, v6, onlyDirectRoutes = false, }) {
        let ixs;
        let lookupTables;
        if (v6) {
            const res = await this.getJupiterSwapIxV6({
                jupiterClient,
                outMarketIndex,
                inMarketIndex,
                outAssociatedTokenAccount,
                inAssociatedTokenAccount,
                amount,
                slippageBps,
                swapMode,
                quote: v6.quote,
                reduceOnly,
                onlyDirectRoutes,
            });
            ixs = res.ixs;
            lookupTables = res.lookupTables;
        }
        else {
            const res = await this.getJupiterSwapIx({
                jupiterClient,
                outMarketIndex,
                inMarketIndex,
                outAssociatedTokenAccount,
                inAssociatedTokenAccount,
                amount,
                slippageBps,
                swapMode,
                route,
                reduceOnly,
            });
            ixs = res.ixs;
            lookupTables = res.lookupTables;
        }
        const tx = (await this.buildTransaction(ixs, txParams, 0, lookupTables));
        const { txSig, slot } = await this.sendTransaction(tx);
        this.spotMarketLastSlotCache.set(outMarketIndex, slot);
        this.spotMarketLastSlotCache.set(inMarketIndex, slot);
        return txSig;
    }
    async getJupiterSwapIx({ jupiterClient, outMarketIndex, inMarketIndex, outAssociatedTokenAccount, inAssociatedTokenAccount, amount, slippageBps, swapMode, onlyDirectRoutes, route, reduceOnly, userAccountPublicKey, }) {
        const outMarket = this.getSpotMarketAccount(outMarketIndex);
        const inMarket = this.getSpotMarketAccount(inMarketIndex);
        if (!route) {
            const routes = await jupiterClient.getRoutes({
                inputMint: inMarket.mint,
                outputMint: outMarket.mint,
                amount,
                slippageBps,
                swapMode,
                onlyDirectRoutes,
            });
            if (!routes || routes.length === 0) {
                throw new Error('No jupiter routes found');
            }
            route = routes[0];
        }
        const transaction = await jupiterClient.getSwapTransaction({
            route,
            userPublicKey: this.provider.wallet.publicKey,
            slippageBps,
        });
        const { transactionMessage, lookupTables } = await jupiterClient.getTransactionMessageAndLookupTables({
            transaction,
        });
        const jupiterInstructions = jupiterClient.getJupiterInstructions({
            transactionMessage,
            inputMint: inMarket.mint,
            outputMint: outMarket.mint,
        });
        const preInstructions = [];
        if (!outAssociatedTokenAccount) {
            outAssociatedTokenAccount = await this.getAssociatedTokenAccount(outMarket.marketIndex, false);
            const accountInfo = await this.connection.getAccountInfo(outAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(outAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, outMarket.mint));
            }
        }
        if (!inAssociatedTokenAccount) {
            inAssociatedTokenAccount = await this.getAssociatedTokenAccount(inMarket.marketIndex, false);
            const accountInfo = await this.connection.getAccountInfo(inAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(inAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, inMarket.mint));
            }
        }
        const { beginSwapIx, endSwapIx } = await this.getSwapIx({
            outMarketIndex,
            inMarketIndex,
            amountIn: amount,
            inTokenAccount: inAssociatedTokenAccount,
            outTokenAccount: outAssociatedTokenAccount,
            reduceOnly,
            userAccountPublicKey,
        });
        const ixs = [
            ...preInstructions,
            beginSwapIx,
            ...jupiterInstructions,
            endSwapIx,
        ];
        return { ixs, lookupTables };
    }
    async getJupiterSwapIxV6({ jupiterClient, outMarketIndex, inMarketIndex, outAssociatedTokenAccount, inAssociatedTokenAccount, amount, slippageBps, swapMode, onlyDirectRoutes, quote, reduceOnly, userAccountPublicKey, }) {
        const outMarket = this.getSpotMarketAccount(outMarketIndex);
        const inMarket = this.getSpotMarketAccount(inMarketIndex);
        if (!quote) {
            const fetchedQuote = await jupiterClient.getQuote({
                inputMint: inMarket.mint,
                outputMint: outMarket.mint,
                amount,
                slippageBps,
                swapMode,
                onlyDirectRoutes,
            });
            quote = fetchedQuote;
        }
        if (!quote) {
            throw new Error("Could not fetch Jupiter's quote. Please try again.");
        }
        const transaction = await jupiterClient.getSwap({
            quote,
            userPublicKey: this.provider.wallet.publicKey,
            slippageBps,
        });
        const { transactionMessage, lookupTables } = await jupiterClient.getTransactionMessageAndLookupTables({
            transaction,
        });
        const jupiterInstructions = jupiterClient.getJupiterInstructions({
            transactionMessage,
            inputMint: inMarket.mint,
            outputMint: outMarket.mint,
        });
        const preInstructions = [];
        if (!outAssociatedTokenAccount) {
            outAssociatedTokenAccount = await this.getAssociatedTokenAccount(outMarket.marketIndex, false);
            const accountInfo = await this.connection.getAccountInfo(outAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(outAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, outMarket.mint));
            }
        }
        if (!inAssociatedTokenAccount) {
            inAssociatedTokenAccount = await this.getAssociatedTokenAccount(inMarket.marketIndex, false);
            const accountInfo = await this.connection.getAccountInfo(inAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(inAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, inMarket.mint));
            }
        }
        const { beginSwapIx, endSwapIx } = await this.getSwapIx({
            outMarketIndex,
            inMarketIndex,
            amountIn: amount,
            inTokenAccount: inAssociatedTokenAccount,
            outTokenAccount: outAssociatedTokenAccount,
            reduceOnly,
            userAccountPublicKey,
        });
        const ixs = [
            ...preInstructions,
            beginSwapIx,
            ...jupiterInstructions,
            endSwapIx,
        ];
        return { ixs, lookupTables };
    }
    /**
     * Get the drift begin_swap and end_swap instructions
     *
     * @param outMarketIndex the market index of the token you're buying
     * @param inMarketIndex the market index of the token you're selling
     * @param amountIn the amount of the token to sell
     * @param inTokenAccount the token account to move the tokens being sold
     * @param outTokenAccount the token account to receive the tokens being bought
     * @param limitPrice the limit price of the swap
     * @param reduceOnly
     * @param userAccountPublicKey optional, specify a custom userAccountPublicKey to use instead of getting the current user account; can be helpful if the account is being created within the current tx
     */
    async getSwapIx({ outMarketIndex, inMarketIndex, amountIn, inTokenAccount, outTokenAccount, limitPrice, reduceOnly, userAccountPublicKey, }) {
        const userAccountPublicKeyToUse = userAccountPublicKey || (await this.getUserAccountPublicKey());
        const userAccounts = [];
        try {
            if (this.hasUser() && this.getUser().getUserAccountAndSlot()) {
                userAccounts.push(this.getUser().getUserAccountAndSlot().data);
            }
        }
        catch (err) {
            // ignore
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writableSpotMarketIndexes: [outMarketIndex, inMarketIndex],
            readableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const outSpotMarket = this.getSpotMarketAccount(outMarketIndex);
        const inSpotMarket = this.getSpotMarketAccount(inMarketIndex);
        const beginSwapIx = await this.program.instruction.beginSwap(inMarketIndex, outMarketIndex, amountIn, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKeyToUse,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                outSpotMarketVault: outSpotMarket.vault,
                inSpotMarketVault: inSpotMarket.vault,
                inTokenAccount,
                outTokenAccount,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                driftSigner: this.getStateAccount().signer,
                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        const endSwapIx = await this.program.instruction.endSwap(inMarketIndex, outMarketIndex, limitPrice !== null && limitPrice !== void 0 ? limitPrice : null, reduceOnly !== null && reduceOnly !== void 0 ? reduceOnly : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKeyToUse,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                outSpotMarketVault: outSpotMarket.vault,
                inSpotMarketVault: inSpotMarket.vault,
                inTokenAccount,
                outTokenAccount,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                driftSigner: this.getStateAccount().signer,
                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        return { beginSwapIx, endSwapIx };
    }
    async stakeForMSOL({ amount }) {
        const ixs = await this.getStakeForMSOLIx({ amount });
        const tx = await this.buildTransaction(ixs);
        return this.sendTransaction(tx);
    }
    async getStakeForMSOLIx({ amount, userAccountPublicKey, }) {
        const wSOLMint = this.getSpotMarketAccount(1).mint;
        const mSOLAccount = await this.getAssociatedTokenAccount(2);
        const wSOLAccount = await this.getAssociatedTokenAccount(1, false);
        const wSOLAccountExists = await this.checkIfAccountExists(wSOLAccount);
        const closeWSOLIx = (0, spl_token_1.createCloseAccountInstruction)(wSOLAccount, this.wallet.publicKey, this.wallet.publicKey);
        const createWSOLIx = await this.createAssociatedTokenAccountIdempotentInstruction(wSOLAccount, this.wallet.publicKey, this.wallet.publicKey, wSOLMint);
        const { beginSwapIx, endSwapIx } = await this.getSwapIx({
            inMarketIndex: 1,
            outMarketIndex: 2,
            amountIn: amount,
            inTokenAccount: wSOLAccount,
            outTokenAccount: mSOLAccount,
            userAccountPublicKey,
        });
        const program = (0, marinade_1.getMarinadeFinanceProgram)(this.provider);
        const depositIx = await (0, marinade_1.getMarinadeDepositIx)({
            program,
            mSOLAccount: mSOLAccount,
            transferFrom: this.wallet.publicKey,
            amount,
        });
        const ixs = [];
        if (!wSOLAccountExists) {
            ixs.push(createWSOLIx);
        }
        ixs.push(beginSwapIx, closeWSOLIx, depositIx, createWSOLIx, endSwapIx);
        return ixs;
    }
    async triggerOrder(userAccountPublicKey, user, order, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getTriggerOrderIx(userAccountPublicKey, user, order, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getTriggerOrderIx(userAccountPublicKey, userAccount, order, fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        let remainingAccountsParams;
        if ((0, types_1.isVariant)(order.marketType, 'perp')) {
            remainingAccountsParams = {
                userAccounts: [userAccount],
                writablePerpMarketIndexes: [order.marketIndex],
            };
        }
        else {
            remainingAccountsParams = {
                userAccounts: [userAccount],
                writableSpotMarketIndexes: [order.marketIndex, numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
            };
        }
        const remainingAccounts = this.getRemainingAccounts(remainingAccountsParams);
        const orderId = order.orderId;
        return await this.program.instruction.triggerOrder(orderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async forceCancelOrders(userAccountPublicKey, user, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getForceCancelOrdersIx(userAccountPublicKey, user, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getForceCancelOrdersIx(userAccountPublicKey, userAccount, fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        return await this.program.instruction.forceCancelOrders({
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateUserIdle(userAccountPublicKey, user, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateUserIdleIx(userAccountPublicKey, user, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateUserIdleIx(userAccountPublicKey, userAccount, fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.updateUserIdle({
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateUserOpenOrdersCount(userAccountPublicKey, user, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateUserOpenOrdersCountIx(userAccountPublicKey, user, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateUserOpenOrdersCountIx(userAccountPublicKey, userAccount, fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.updateUserOpenOrdersCount({
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndTakePerpOrder(orderParams, makerInfo, referrerInfo, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlaceAndTakePerpOrderIx(orderParams, makerInfo, referrerInfo, subAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async placeAndTakePerpWithAdditionalOrders(orderParams, makerInfo, referrerInfo, bracketOrdersParams = new Array(), txParams, subAccountId, cancelExistingOrders, settlePnl, simulateFirst) {
        const ixs = [];
        const placeAndTakeIx = await this.getPlaceAndTakePerpOrderIx(orderParams, makerInfo, referrerInfo, subAccountId);
        ixs.push(placeAndTakeIx);
        if (bracketOrdersParams.length > 0) {
            const bracketOrdersIx = await this.getPlaceOrdersIx(bracketOrdersParams, subAccountId);
            ixs.push(bracketOrdersIx);
        }
        const shouldUseSimulationComputeUnits = txParams === null || txParams === void 0 ? void 0 : txParams.useSimulatedComputeUnits;
        const shouldExitIfSimulationFails = simulateFirst;
        const txParamsWithoutImplicitSimulation = {
            ...txParams,
            useSimulationComputeUnits: false,
        };
        let placeAndTakeTx = await this.buildTransaction(ixs, txParamsWithoutImplicitSimulation);
        if (shouldUseSimulationComputeUnits || shouldExitIfSimulationFails) {
            let versionedPlaceAndTakeTx;
            if (this.isVersionedTransaction(placeAndTakeTx)) {
                versionedPlaceAndTakeTx = placeAndTakeTx;
            }
            else {
                versionedPlaceAndTakeTx = (await this.buildTransaction(ixs, txParamsWithoutImplicitSimulation, undefined, undefined, true));
            }
            const simulationResult = await txParamProcessor_1.TransactionProcessor.getTxSimComputeUnits(versionedPlaceAndTakeTx, this.connection);
            if (shouldExitIfSimulationFails && !simulationResult.success) {
                return;
            }
            if (shouldUseSimulationComputeUnits) {
                placeAndTakeTx = await this.buildTransaction(ixs, {
                    ...txParamsWithoutImplicitSimulation,
                    computeUnits: simulationResult.computeUnits,
                });
            }
        }
        let cancelExistingOrdersTx;
        if (cancelExistingOrders && (0, types_1.isVariant)(orderParams.marketType, 'perp')) {
            const cancelOrdersIx = await this.getCancelOrdersIx(orderParams.marketType, orderParams.marketIndex, null, subAccountId);
            //@ts-ignore
            cancelExistingOrdersTx = await this.buildTransaction([cancelOrdersIx], txParams, this.txVersion);
        }
        /* Settle PnL after fill if requested */
        let settlePnlTx;
        if (settlePnl && (0, types_1.isVariant)(orderParams.marketType, 'perp')) {
            const userAccountPublicKey = await this.getUserAccountPublicKey(subAccountId);
            const settlePnlIx = await this.settlePNLIx(userAccountPublicKey, this.getUserAccount(subAccountId), orderParams.marketIndex);
            //@ts-ignore
            settlePnlTx = await this.buildTransaction([settlePnlIx], txParams, this.txVersion);
        }
        const allPossibleTxs = [
            placeAndTakeTx,
            cancelExistingOrdersTx,
            settlePnlTx,
        ];
        const txKeys = [
            'signedPlaceAndTakeTx',
            'signedCancelExistingOrdersTx',
            'signedSettlePnlTx',
        ];
        const { signedPlaceAndTakeTx, signedCancelExistingOrdersTx, signedSettlePnlTx, } = await (0, utils_1.getSignedTransactionMap)(
        //@ts-ignore
        this.provider.wallet, allPossibleTxs, txKeys);
        const { txSig, slot } = await this.sendTransaction(signedPlaceAndTakeTx, [], this.opts, true);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        //@ts-ignore
        return { txSig, signedCancelExistingOrdersTx, signedSettlePnlTx };
    }
    async getPlaceAndTakePerpOrderIx(orderParams, makerInfo, referrerInfo, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.PERP });
        const userStatsPublicKey = await this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        makerInfo = Array.isArray(makerInfo)
            ? makerInfo
            : makerInfo
                ? [makerInfo]
                : [];
        const userAccounts = [this.getUserAccount(subAccountId)];
        for (const maker of makerInfo) {
            userAccounts.push(maker.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [orderParams.marketIndex],
        });
        for (const maker of makerInfo) {
            remainingAccounts.push({
                pubkey: maker.maker,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: maker.makerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        if (referrerInfo) {
            const referrerIsMaker = makerInfo.find((maker) => maker.maker.equals(referrerInfo.referrer)) !==
                undefined;
            if (!referrerIsMaker) {
                remainingAccounts.push({
                    pubkey: referrerInfo.referrer,
                    isWritable: true,
                    isSigner: false,
                });
                remainingAccounts.push({
                    pubkey: referrerInfo.referrerStats,
                    isWritable: true,
                    isSigner: false,
                });
            }
        }
        return await this.program.instruction.placeAndTakePerpOrder(orderParams, null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndMakePerpOrder(orderParams, takerInfo, referrerInfo, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlaceAndMakePerpOrderIx(orderParams, takerInfo, referrerInfo, subAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async getPlaceAndMakePerpOrderIx(orderParams, takerInfo, referrerInfo, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.PERP });
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [
                this.getUserAccount(subAccountId),
                takerInfo.takerUserAccount,
            ],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [orderParams.marketIndex],
        });
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const takerOrderId = takerInfo.order.orderId;
        return await this.program.instruction.placeAndMakePerpOrder(orderParams, takerOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                taker: takerInfo.taker,
                takerStats: takerInfo.takerStats,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndTakeSpotOrder(orderParams, fulfillmentConfig, makerInfo, referrerInfo, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlaceAndTakeSpotOrderIx(orderParams, fulfillmentConfig, makerInfo, referrerInfo, subAccountId), txParams), [], this.opts);
        this.spotMarketLastSlotCache.set(orderParams.marketIndex, slot);
        this.spotMarketLastSlotCache.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, slot);
        return txSig;
    }
    async getPlaceAndTakeSpotOrderIx(orderParams, fulfillmentConfig, makerInfo, referrerInfo, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.SPOT });
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        const userAccounts = [this.getUserAccount(subAccountId)];
        if (makerInfo !== undefined) {
            userAccounts.push(makerInfo.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [
                orderParams.marketIndex,
                numericConstants_1.QUOTE_SPOT_MARKET_INDEX,
            ],
        });
        let makerOrderId = null;
        if (makerInfo) {
            makerOrderId = makerInfo.order.orderId;
            remainingAccounts.push({
                pubkey: makerInfo.maker,
                isSigner: false,
                isWritable: true,
            });
            remainingAccounts.push({
                pubkey: makerInfo.makerStats,
                isSigner: false,
                isWritable: true,
            });
        }
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        this.addSpotFulfillmentAccounts(orderParams.marketIndex, remainingAccounts, fulfillmentConfig);
        return await this.program.instruction.placeAndTakeSpotOrder(orderParams, fulfillmentConfig ? fulfillmentConfig.fulfillmentType : null, makerOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndMakeSpotOrder(orderParams, takerInfo, fulfillmentConfig, referrerInfo, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlaceAndMakeSpotOrderIx(orderParams, takerInfo, fulfillmentConfig, referrerInfo, subAccountId), txParams), [], this.opts);
        this.spotMarketLastSlotCache.set(orderParams.marketIndex, slot);
        this.spotMarketLastSlotCache.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, slot);
        return txSig;
    }
    async getPlaceAndMakeSpotOrderIx(orderParams, takerInfo, fulfillmentConfig, referrerInfo, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.SPOT });
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [
                this.getUserAccount(subAccountId),
                takerInfo.takerUserAccount,
            ],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [
                orderParams.marketIndex,
                numericConstants_1.QUOTE_SPOT_MARKET_INDEX,
            ],
        });
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        this.addSpotFulfillmentAccounts(orderParams.marketIndex, remainingAccounts, fulfillmentConfig);
        const takerOrderId = takerInfo.order.orderId;
        return await this.program.instruction.placeAndMakeSpotOrder(orderParams, takerOrderId, fulfillmentConfig ? fulfillmentConfig.fulfillmentType : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                taker: takerInfo.taker,
                takerStats: takerInfo.takerStats,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    /**
     * @deprecated use {@link placePerpOrder} or {@link placeAndTakePerpOrder} instead
     */
    async closePosition(marketIndex, limitPrice, subAccountId) {
        const userPosition = this.getUser(subAccountId).getPerpPosition(marketIndex);
        if (!userPosition) {
            throw Error(`No position in market ${marketIndex.toString()}`);
        }
        return await this.placeAndTakePerpOrder({
            orderType: types_1.OrderType.MARKET,
            marketIndex,
            direction: (0, position_1.findDirectionToClose)(userPosition),
            baseAssetAmount: userPosition.baseAssetAmount.abs(),
            reduceOnly: true,
            price: limitPrice,
        }, undefined, undefined, undefined, subAccountId);
    }
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @deprecated use modifyOrder instead
     * @param orderId: The open order to modify
     * @param newBaseAmount: The new base amount for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newLimitPice: The new limit price for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newOraclePriceOffset: The new oracle price offset for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @returns
     */
    async modifyPerpOrder(orderId, newBaseAmount, newLimitPrice, newOraclePriceOffset) {
        return this.modifyOrder({
            orderId,
            newBaseAmount,
            newLimitPrice,
            newOraclePriceOffset,
        });
    }
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @deprecated use modifyOrderByUserOrderId instead
     * @param userOrderId: The open order to modify
     * @param newBaseAmount: The new base amount for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newLimitPice: The new limit price for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newOraclePriceOffset: The new oracle price offset for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @returns
     */
    async modifyPerpOrderByUserOrderId(userOrderId, newBaseAmount, newLimitPrice, newOraclePriceOffset) {
        return this.modifyOrderByUserOrderId({
            userOrderId,
            newBaseAmount,
            newLimitPrice,
            newOraclePriceOffset,
        });
    }
    /**
     * Modifies an open order (spot or perp) by closing it and replacing it with a new order.
     * @param orderParams.orderId: The open order to modify
     * @param orderParams.newDirection: The new direction for the order
     * @param orderParams.newBaseAmount: The new base amount for the order
     * @param orderParams.newLimitPice: The new limit price for the order
     * @param orderParams.newOraclePriceOffset: The new oracle price offset for the order
     * @param orderParams.newTriggerPrice: Optional - Thew new trigger price for the order.
     * @param orderParams.auctionDuration:
     * @param orderParams.auctionStartPrice:
     * @param orderParams.auctionEndPrice:
     * @param orderParams.reduceOnly:
     * @param orderParams.postOnly:
     * @param orderParams.immediateOrCancel:
     * @param orderParams.policy:
     * @param orderParams.maxTs:
     * @returns
     */
    async modifyOrder(orderParams, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getModifyOrderIx(orderParams, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getModifyOrderIx({ orderId, newDirection, newBaseAmount, newLimitPrice, newOraclePriceOffset, newTriggerPrice, newTriggerCondition, auctionDuration, auctionStartPrice, auctionEndPrice, reduceOnly, postOnly, immediateOrCancel, maxTs, policy, }, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        const orderParams = {
            baseAssetAmount: newBaseAmount || null,
            direction: newDirection || null,
            price: newLimitPrice || null,
            oraclePriceOffset: newOraclePriceOffset || null,
            triggerPrice: newTriggerPrice || null,
            triggerCondition: newTriggerCondition || null,
            auctionDuration: auctionDuration || 0,
            auctionStartPrice: auctionStartPrice || numericConstants_1.ZERO,
            auctionEndPrice: auctionEndPrice || numericConstants_1.ZERO,
            reduceOnly: reduceOnly != undefined ? reduceOnly : null,
            postOnly: postOnly != undefined ? postOnly : null,
            immediateOrCancel: immediateOrCancel != undefined ? immediateOrCancel : null,
            policy: policy || null,
            maxTs: maxTs || null,
        };
        return await this.program.instruction.modifyOrder(orderId, orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @param orderParams.userOrderId: The open order to modify
     * @param orderParams.newDirection: The new direction for the order
     * @param orderParams.newBaseAmount: The new base amount for the order
     * @param orderParams.newLimitPice: The new limit price for the order
     * @param orderParams.newOraclePriceOffset: The new oracle price offset for the order
     * @param orderParams.newTriggerPrice: Optional - Thew new trigger price for the order.
     * @param orderParams.auctionDuration: Only required if order type changed to market from something else
     * @param orderParams.auctionStartPrice: Only required if order type changed to market from something else
     * @param orderParams.auctionEndPrice: Only required if order type changed to market from something else
     * @param orderParams.reduceOnly:
     * @param orderParams.postOnly:
     * @param orderParams.immediateOrCancel:
     * @param orderParams.policy:
     * @param orderParams.maxTs:
     * @returns
     */
    async modifyOrderByUserOrderId(orderParams, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getModifyOrderByUserIdIx(orderParams, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getModifyOrderByUserIdIx({ userOrderId, newDirection, newBaseAmount, newLimitPrice, newOraclePriceOffset, newTriggerPrice, newTriggerCondition, auctionDuration, auctionStartPrice, auctionEndPrice, reduceOnly, postOnly, immediateOrCancel, maxTs, policy, }, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        const orderParams = {
            baseAssetAmount: newBaseAmount || null,
            direction: newDirection || null,
            price: newLimitPrice || null,
            oraclePriceOffset: newOraclePriceOffset || null,
            triggerPrice: newTriggerPrice || null,
            triggerCondition: newTriggerCondition || null,
            auctionDuration: auctionDuration || null,
            auctionStartPrice: auctionStartPrice || null,
            auctionEndPrice: auctionEndPrice || null,
            reduceOnly: reduceOnly || false,
            postOnly: postOnly || null,
            immediateOrCancel: immediateOrCancel || false,
            policy: policy || null,
            maxTs: maxTs || null,
        };
        return await this.program.instruction.modifyOrderByUserId(userOrderId, orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async settlePNLs(users, marketIndexes, opts) {
        const filterInvalidMarkets = opts === null || opts === void 0 ? void 0 : opts.filterInvalidMarkets;
        // # Filter market indexes by markets with valid oracle
        const marketIndexToSettle = filterInvalidMarkets
            ? []
            : marketIndexes;
        if (filterInvalidMarkets) {
            for (const marketIndex of marketIndexes) {
                const perpMarketAccount = this.getPerpMarketAccount(marketIndex);
                const oraclePriceData = this.getOracleDataForPerpMarket(marketIndex);
                const stateAccountAndSlot = this.accountSubscriber.getStateAccountAndSlot();
                const oracleGuardRails = stateAccountAndSlot.data.oracleGuardRails;
                const isValid = (0, oracles_1.isOracleValid)(perpMarketAccount, oraclePriceData, oracleGuardRails, stateAccountAndSlot.slot);
                if (isValid) {
                    marketIndexToSettle.push(marketIndex);
                }
            }
        }
        // # Settle filtered market indexes
        const ixs = await this.getSettlePNLsIxs(users, marketIndexToSettle);
        const tx = await this.buildTransaction(ixs, {
            computeUnits: 1400000,
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getSettlePNLsIxs(users, marketIndexes) {
        const ixs = [];
        for (const { settleeUserAccountPublicKey, settleeUserAccount } of users) {
            for (const marketIndex of marketIndexes) {
                ixs.push(await this.settlePNLIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndex));
            }
        }
        return ixs;
    }
    async settlePNL(settleeUserAccountPublicKey, settleeUserAccount, marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.settlePNLIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async settlePNLIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndex) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [settleeUserAccount],
            writablePerpMarketIndexes: [marketIndex],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        return await this.program.instruction.settlePnl(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: settleeUserAccountPublicKey,
                spotMarketVault: this.getQuoteSpotMarketAccount().vault,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidatePerp(userAccountPublicKey, userAccount, marketIndex, maxBaseAssetAmount, limitPrice, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidatePerpIx(userAccountPublicKey, userAccount, marketIndex, maxBaseAssetAmount, limitPrice, liquidatorSubAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getLiquidatePerpIx(userAccountPublicKey, userAccount, marketIndex, maxBaseAssetAmount, limitPrice, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        return await this.program.instruction.liquidatePerp(marketIndex, maxBaseAssetAmount, limitPrice !== null && limitPrice !== void 0 ? limitPrice : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidateSpot(userAccountPublicKey, userAccount, assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidateSpotIx(userAccountPublicKey, userAccount, assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, liquidatorSubAccountId), txParams), [], this.opts);
        this.spotMarketLastSlotCache.set(assetMarketIndex, slot);
        this.spotMarketLastSlotCache.set(liabilityMarketIndex, slot);
        return txSig;
    }
    async getLiquidateSpotIx(userAccountPublicKey, userAccount, assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [liabilityMarketIndex, assetMarketIndex],
        });
        return await this.program.instruction.liquidateSpot(assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice || null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidateBorrowForPerpPnl(userAccountPublicKey, userAccount, perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidateBorrowForPerpPnlIx(userAccountPublicKey, userAccount, perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, liquidatorSubAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(perpMarketIndex, slot);
        this.spotMarketLastSlotCache.set(liabilityMarketIndex, slot);
        return txSig;
    }
    async getLiquidateBorrowForPerpPnlIx(userAccountPublicKey, userAccount, perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            writablePerpMarketIndexes: [perpMarketIndex],
            writableSpotMarketIndexes: [liabilityMarketIndex],
        });
        return await this.program.instruction.liquidateBorrowForPerpPnl(perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice || null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidatePerpPnlForDeposit(userAccountPublicKey, userAccount, perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidatePerpPnlForDepositIx(userAccountPublicKey, userAccount, perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice, liquidatorSubAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(perpMarketIndex, slot);
        this.spotMarketLastSlotCache.set(assetMarketIndex, slot);
        return txSig;
    }
    async getLiquidatePerpPnlForDepositIx(userAccountPublicKey, userAccount, perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            writablePerpMarketIndexes: [perpMarketIndex],
            writableSpotMarketIndexes: [assetMarketIndex],
        });
        return await this.program.instruction.liquidatePerpPnlForDeposit(perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice || null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async resolvePerpBankruptcy(userAccountPublicKey, userAccount, marketIndex, txParams, liquidatorSubAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getResolvePerpBankruptcyIx(userAccountPublicKey, userAccount, marketIndex, liquidatorSubAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getResolvePerpBankruptcyIx(userAccountPublicKey, userAccount, marketIndex, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            writablePerpMarketIndexes: [marketIndex],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const spotMarket = this.getQuoteSpotMarketAccount();
        return await this.program.instruction.resolvePerpBankruptcy(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async resolveSpotBankruptcy(userAccountPublicKey, userAccount, marketIndex, txParams, liquidatorSubAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getResolveSpotBankruptcyIx(userAccountPublicKey, userAccount, marketIndex, liquidatorSubAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getResolveSpotBankruptcyIx(userAccountPublicKey, userAccount, marketIndex, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            writableSpotMarketIndexes: [marketIndex],
        });
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return await this.program.instruction.resolveSpotBankruptcy(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
                liquidator,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async updateFundingRate(perpMarketIndex, oracle, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateFundingRateIx(perpMarketIndex, oracle), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateFundingRateIx(perpMarketIndex, oracle) {
        const perpMarketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, perpMarketIndex);
        return await this.program.instruction.updateFundingRate(perpMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                perpMarket: perpMarketPublicKey,
                oracle: oracle,
            },
        });
    }
    async updatePrelaunchOracle(perpMarketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdatePrelaunchOracleIx(perpMarketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getUpdatePrelaunchOracleIx(perpMarketIndex) {
        const perpMarket = this.getPerpMarketAccount(perpMarketIndex);
        if (!(0, types_1.isVariant)(perpMarket.amm.oracleSource, 'prelaunch')) {
            throw new Error(`Wrong oracle source ${perpMarket.amm.oracleSource}`);
        }
        return await this.program.instruction.updatePrelaunchOracle({
            accounts: {
                state: await this.getStatePublicKey(),
                perpMarket: perpMarket.pubkey,
                oracle: perpMarket.amm.oracle,
            },
        });
    }
    async updatePerpBidAskTwap(perpMarketIndex, makers, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdatePerpBidAskTwapIx(perpMarketIndex, makers), txParams), [], this.opts);
        return txSig;
    }
    async getUpdatePerpBidAskTwapIx(perpMarketIndex, makers) {
        const perpMarket = this.getPerpMarketAccount(perpMarketIndex);
        const remainingAccounts = [];
        for (const [maker, makerStats] of makers) {
            remainingAccounts.push({
                pubkey: maker,
                isWritable: false,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: makerStats,
                isWritable: false,
                isSigner: false,
            });
        }
        return await this.program.instruction.updatePerpBidAskTwap({
            accounts: {
                state: await this.getStatePublicKey(),
                perpMarket: perpMarket.pubkey,
                oracle: perpMarket.amm.oracle,
                authority: this.wallet.publicKey,
                keeperStats: this.getUserStatsAccountPublicKey(),
            },
            remainingAccounts,
        });
    }
    async settleFundingPayment(userAccountPublicKey, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getSettleFundingPaymentIx(userAccountPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getSettleFundingPaymentIx(userAccountPublicKey) {
        const userAccount = (await this.program.account.user.fetch(userAccountPublicKey));
        const writablePerpMarketIndexes = [];
        for (const position of userAccount.perpPositions) {
            if (!(0, position_1.positionIsAvailable)(position)) {
                writablePerpMarketIndexes.push(position.marketIndex);
            }
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            writablePerpMarketIndexes,
        });
        return await this.program.instruction.settleFundingPayment({
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
            },
            remainingAccounts,
        });
    }
    triggerEvent(eventName, data) {
        this.eventEmitter.emit(eventName, data);
    }
    getOracleDataForPerpMarket(marketIndex) {
        return this.accountSubscriber.getOraclePriceDataAndSlotForPerpMarket(marketIndex).data;
    }
    getOracleDataForSpotMarket(marketIndex) {
        return this.accountSubscriber.getOraclePriceDataAndSlotForSpotMarket(marketIndex).data;
    }
    async initializeInsuranceFundStake(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getInitializeInsuranceFundStakeIx(marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getInitializeInsuranceFundStakeIx(marketIndex) {
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        return await this.program.instruction.initializeInsuranceFundStake(marketIndex, {
            accounts: {
                insuranceFundStake: ifStakeAccountPublicKey,
                spotMarket: this.getSpotMarketAccount(marketIndex).pubkey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
                state: await this.getStatePublicKey(),
            },
        });
    }
    async getAddInsuranceFundStakeIx(marketIndex, amount, collateralAccountPublicKey) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [marketIndex],
        });
        const ix = this.program.instruction.addInsuranceFundStake(marketIndex, amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                userTokenAccount: collateralAccountPublicKey,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts,
        });
        return ix;
    }
    /**
     * Add to an insurance fund stake and optionally initialize the account
     */
    async addInsuranceFundStake({ marketIndex, amount, collateralAccountPublicKey, initializeStakeAccount, fromSubaccount, txParams, }) {
        const addIfStakeIxs = [];
        const additionalSigners = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const createWSOLTokenAccount = isSolMarket && collateralAccountPublicKey.equals(this.wallet.publicKey);
        let tokenAccount;
        if (createWSOLTokenAccount) {
            const { ixs, pubkey } = await this.getWrappedSolAccountCreationIxs(amount, true);
            tokenAccount = pubkey;
            ixs.forEach((ix) => {
                addIfStakeIxs.push(ix);
            });
        }
        else {
            tokenAccount = collateralAccountPublicKey;
        }
        if (fromSubaccount) {
            const withdrawIx = await this.getWithdrawIx(amount, marketIndex, tokenAccount);
            addIfStakeIxs.push(withdrawIx);
        }
        if (initializeStakeAccount) {
            const initializeIx = await this.getInitializeInsuranceFundStakeIx(marketIndex);
            addIfStakeIxs.push(initializeIx);
        }
        const addFundsIx = await this.getAddInsuranceFundStakeIx(marketIndex, amount, tokenAccount);
        addIfStakeIxs.push(addFundsIx);
        if (createWSOLTokenAccount) {
            addIfStakeIxs.push((0, spl_token_1.createCloseAccountInstruction)(tokenAccount, this.wallet.publicKey, this.wallet.publicKey, []));
        }
        const tx = await this.buildTransaction(addIfStakeIxs, txParams);
        const { txSig } = await this.sendTransaction(tx, additionalSigners, this.opts);
        return txSig;
    }
    async requestRemoveInsuranceFundStake(marketIndex, amount, txParams) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [marketIndex],
        });
        const ix = await this.program.instruction.requestRemoveInsuranceFundStake(marketIndex, amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
            },
            remainingAccounts,
        });
        const tx = await this.buildTransaction(ix, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async cancelRequestRemoveInsuranceFundStake(marketIndex, txParams) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [marketIndex],
        });
        const ix = await this.program.instruction.cancelRequestRemoveInsuranceFundStake(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
            },
            remainingAccounts,
        });
        const tx = await this.buildTransaction(ix, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async removeInsuranceFundStake(marketIndex, collateralAccountPublicKey, txParams) {
        var _a, _b;
        const removeIfStakeIxs = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const additionalSigners = [];
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const createWSOLTokenAccount = isSolMarket && collateralAccountPublicKey.equals(this.wallet.publicKey);
        let tokenAccount;
        if (createWSOLTokenAccount) {
            const { ixs, pubkey } = await this.getWrappedSolAccountCreationIxs(numericConstants_1.ZERO, true);
            tokenAccount = pubkey;
            ixs.forEach((ix) => {
                removeIfStakeIxs.push(ix);
            });
        }
        else {
            tokenAccount = collateralAccountPublicKey;
            const tokenAccountExists = await this.checkIfAccountExists(tokenAccount);
            if (!tokenAccountExists) {
                const createTokenAccountIx = await this.createAssociatedTokenAccountIdempotentInstruction(tokenAccount, this.wallet.publicKey, this.wallet.publicKey, spotMarketAccount.mint);
                removeIfStakeIxs.push(createTokenAccountIx);
            }
        }
        const userAccountExists = !!((_b = (_a = this.getUser()) === null || _a === void 0 ? void 0 : _a.accountSubscriber) === null || _b === void 0 ? void 0 : _b.isSubscribed) &&
            (await this.checkIfAccountExists(this.getUser().userAccountPublicKey));
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: userAccountExists ? [this.getUserAccount()] : [],
            useMarketLastSlotCache: false,
            writableSpotMarketIndexes: [marketIndex],
        });
        const removeStakeIx = await this.program.instruction.removeInsuranceFundStake(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                userTokenAccount: tokenAccount,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts,
        });
        removeIfStakeIxs.push(removeStakeIx);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            removeIfStakeIxs.push((0, spl_token_1.createCloseAccountInstruction)(tokenAccount, this.wallet.publicKey, this.wallet.publicKey, []));
        }
        const tx = await this.buildTransaction(removeIfStakeIxs, txParams);
        const { txSig } = await this.sendTransaction(tx, additionalSigners, this.opts);
        return txSig;
    }
    async settleRevenueToInsuranceFund(spotMarketIndex, subAccountId, txParams) {
        const tx = await this.buildTransaction(await this.getSettleRevenueToInsuranceFundIx(spotMarketIndex, subAccountId), txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getSettleRevenueToInsuranceFundIx(spotMarketIndex, subAccountId) {
        const spotMarketAccount = this.getSpotMarketAccount(spotMarketIndex);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [spotMarketIndex],
        });
        const ix = await this.program.instruction.settleRevenueToInsuranceFund(spotMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                spotMarketVault: spotMarketAccount.vault,
                driftSigner: this.getSignerPublicKey(),
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts,
        });
        return ix;
    }
    async resolvePerpPnlDeficit(spotMarketIndex, perpMarketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getResolvePerpPnlDeficitIx(spotMarketIndex, perpMarketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getResolvePerpPnlDeficitIx(spotMarketIndex, perpMarketIndex) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [perpMarketIndex],
            writableSpotMarketIndexes: [spotMarketIndex],
        });
        const spotMarket = this.getSpotMarketAccount(spotMarketIndex);
        return await this.program.instruction.resolvePerpPnlDeficit(spotMarketIndex, perpMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async getDepositIntoSpotMarketRevenuePoolIx(marketIndex, amount, userTokenAccountPublicKey) {
        const spotMarket = await this.getSpotMarketAccount(marketIndex);
        const ix = await this.program.instruction.depositIntoSpotMarketRevenuePool(amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                authority: this.wallet.publicKey,
                spotMarketVault: spotMarket.vault,
                userTokenAccount: userTokenAccountPublicKey,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
        });
        return ix;
    }
    async depositIntoSpotMarketRevenuePool(marketIndex, amount, userTokenAccountPublicKey) {
        const ix = await this.getDepositIntoSpotMarketRevenuePoolIx(marketIndex, amount, userTokenAccountPublicKey);
        const tx = await this.buildTransaction([ix]);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    getPerpMarketExtendedInfo(marketIndex) {
        var _a, _b;
        const marketAccount = this.getPerpMarketAccount(marketIndex);
        const quoteAccount = this.getSpotMarketAccount(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        const extendedInfo = {
            marketIndex,
            minOrderSize: (_a = marketAccount.amm) === null || _a === void 0 ? void 0 : _a.minOrderSize,
            marginMaintenance: marketAccount.marginRatioMaintenance,
            pnlPoolValue: (0, spotBalance_1.getTokenAmount)((_b = marketAccount.pnlPool) === null || _b === void 0 ? void 0 : _b.scaledBalance, quoteAccount, types_1.SpotBalanceType.DEPOSIT),
            contractTier: marketAccount.contractTier,
            availableInsurance: (0, market_1.calculateMarketMaxAvailableInsurance)(marketAccount, quoteAccount),
        };
        return extendedInfo;
    }
    /**
     * Calculates taker / maker fee (as a percentage, e.g. .001 = 10 basis points) for particular marketType
     * @param marketType
     * @param positionMarketIndex
     * @returns : {takerFee: number, makerFee: number} Precision None
     */
    getMarketFees(marketType, marketIndex, user) {
        let feeTier;
        if (user) {
            feeTier = user.getUserFeeTier(marketType);
        }
        else {
            const state = this.getStateAccount();
            feeTier = (0, types_1.isVariant)(marketType, 'perp')
                ? state.perpFeeStructure.feeTiers[0]
                : state.spotFeeStructure.feeTiers[0];
        }
        let takerFee = feeTier.feeNumerator / feeTier.feeDenominator;
        let makerFee = feeTier.makerRebateNumerator / feeTier.makerRebateDenominator;
        if (marketIndex !== undefined) {
            let marketAccount = null;
            if ((0, types_1.isVariant)(marketType, 'perp')) {
                marketAccount = this.getPerpMarketAccount(marketIndex);
            }
            else {
                marketAccount = this.getSpotMarketAccount(marketIndex);
            }
            takerFee += (takerFee * marketAccount.feeAdjustment) / 100;
            makerFee += (makerFee * marketAccount.feeAdjustment) / 100;
        }
        return {
            takerFee,
            makerFee,
        };
    }
    /**
     * Returns the market index and type for a given market name
     * E.g. "SOL-PERP" -> { marketIndex: 0, marketType: MarketType.PERP }
     *
     * @param name
     */
    getMarketIndexAndType(name) {
        name = name.toUpperCase();
        for (const perpMarketAccount of this.getPerpMarketAccounts()) {
            if ((0, userName_1.decodeName)(perpMarketAccount.name).toUpperCase() === name) {
                return {
                    marketIndex: perpMarketAccount.marketIndex,
                    marketType: types_1.MarketType.PERP,
                };
            }
        }
        for (const spotMarketAccount of this.getSpotMarketAccounts()) {
            if ((0, userName_1.decodeName)(spotMarketAccount.name).toUpperCase() === name) {
                return {
                    marketIndex: spotMarketAccount.marketIndex,
                    marketType: types_1.MarketType.SPOT,
                };
            }
        }
        return undefined;
    }
    handleSignedTransaction() {
        this.metricsEventEmitter.emit('txSigned');
    }
    isVersionedTransaction(tx) {
        const version = tx === null || tx === void 0 ? void 0 : tx.version;
        const isVersionedTx = tx instanceof web3_js_1.VersionedTransaction || version !== undefined;
        return isVersionedTx;
    }
    sendTransaction(tx, additionalSigners, opts, preSigned) {
        const extraConfirmationOptions = this
            .enableMetricsEvents
            ? {
                onSignedCb: this.handleSignedTransaction.bind(this),
            }
            : undefined;
        const isVersionedTx = this.isVersionedTransaction(tx);
        if (isVersionedTx) {
            return this.txSender.sendVersionedTransaction(tx, additionalSigners, opts, preSigned, extraConfirmationOptions);
        }
        else {
            return this.txSender.send(tx, additionalSigners, opts, preSigned, extraConfirmationOptions);
        }
    }
    /**
     *
     * @param instructions
     * @param txParams
     * @param txVersion
     * @param lookupTables
     * @param forceVersionedTransaction Return a VersionedTransaction instance even if the version of the transaction is Legacy
     * @returns
     */
    async buildTransaction(instructions, txParams, txVersion, lookupTables, forceVersionedTransaction) {
        var _a, _b;
        txVersion = txVersion !== null && txVersion !== void 0 ? txVersion : this.txVersion;
        // # Collect and process Tx Params
        let baseTxParams = {
            computeUnits: (_a = txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits) !== null && _a !== void 0 ? _a : this.txParams.computeUnits,
            computeUnitsPrice: (_b = txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice) !== null && _b !== void 0 ? _b : this.txParams.computeUnitsPrice,
        };
        if (txParams === null || txParams === void 0 ? void 0 : txParams.useSimulatedComputeUnits) {
            const splitTxParams = {
                baseTxParams: {
                    computeUnits: txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits,
                    computeUnitsPrice: txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice,
                },
                txParamProcessingParams: {
                    useSimulatedComputeUnits: txParams === null || txParams === void 0 ? void 0 : txParams.useSimulatedComputeUnits,
                    computeUnitsBufferMultiplier: txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsBufferMultiplier,
                    useSimulatedComputeUnitsForCUPriceCalculation: txParams === null || txParams === void 0 ? void 0 : txParams.useSimulatedComputeUnitsForCUPriceCalculation,
                    getCUPriceFromComputeUnits: txParams === null || txParams === void 0 ? void 0 : txParams.getCUPriceFromComputeUnits,
                },
            };
            const processedTxParams = await this.getProcessedTransactionParams({
                instructions,
                txParams: splitTxParams.baseTxParams,
                txVersion,
                lookupTables,
            }, splitTxParams.txParamProcessingParams);
            baseTxParams = {
                ...baseTxParams,
                ...processedTxParams,
            };
        }
        // # Create Tx Instructions
        const allIx = [];
        const computeUnits = baseTxParams === null || baseTxParams === void 0 ? void 0 : baseTxParams.computeUnits;
        if (computeUnits !== 200000) {
            allIx.push(web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
                units: computeUnits,
            }));
        }
        const computeUnitsPrice = baseTxParams === null || baseTxParams === void 0 ? void 0 : baseTxParams.computeUnitsPrice;
        if (computeUnitsPrice !== 0) {
            allIx.push(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                microLamports: computeUnitsPrice,
            }));
        }
        if (Array.isArray(instructions)) {
            allIx.push(...instructions);
        }
        else {
            allIx.push(instructions);
        }
        const latestBlockHashAndContext = await this.connection.getLatestBlockhashAndContext({
            commitment: this.opts.preflightCommitment,
        });
        // # Create and return Transaction
        if (txVersion === 'legacy') {
            if (forceVersionedTransaction) {
                const message = new web3_js_1.TransactionMessage({
                    payerKey: this.provider.wallet.publicKey,
                    recentBlockhash: latestBlockHashAndContext.value.blockhash,
                    instructions: allIx,
                }).compileToLegacyMessage();
                return new web3_js_1.VersionedTransaction(message);
            }
            else {
                return new web3_js_1.Transaction().add(...allIx);
            }
        }
        else {
            const marketLookupTable = await this.fetchMarketLookupTableAccount();
            lookupTables = lookupTables
                ? [...lookupTables, marketLookupTable]
                : [marketLookupTable];
            const message = new web3_js_1.TransactionMessage({
                payerKey: this.provider.wallet.publicKey,
                recentBlockhash: latestBlockHashAndContext.value.blockhash,
                instructions: allIx,
            }).compileToV0Message(lookupTables);
            return new web3_js_1.VersionedTransaction(message);
        }
    }
}
exports.DriftClient = DriftClient;
