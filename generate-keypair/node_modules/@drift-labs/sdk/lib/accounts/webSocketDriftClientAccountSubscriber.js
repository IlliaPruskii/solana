"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketDriftClientAccountSubscriber = void 0;
const types_1 = require("./types");
const events_1 = require("events");
const pda_1 = require("../addresses/pda");
const webSocketAccountSubscriber_1 = require("./webSocketAccountSubscriber");
const web3_js_1 = require("@solana/web3.js");
const oracleClientCache_1 = require("../oracles/oracleClientCache");
const quoteAssetOracleClient_1 = require("../oracles/quoteAssetOracleClient");
const config_1 = require("../config");
class WebSocketDriftClientAccountSubscriber {
    constructor(program, perpMarketIndexes, spotMarketIndexes, oracleInfos, shouldFindAllMarketsAndOracles, resubOpts, commitment) {
        this.oracleClientCache = new oracleClientCache_1.OracleClientCache();
        this.perpMarketAccountSubscribers = new Map();
        this.perpOracleMap = new Map();
        this.spotMarketAccountSubscribers = new Map();
        this.spotOracleMap = new Map();
        this.oracleSubscribers = new Map();
        this.isSubscribing = false;
        this.isSubscribed = false;
        this.program = program;
        this.eventEmitter = new events_1.EventEmitter();
        this.perpMarketIndexes = perpMarketIndexes;
        this.spotMarketIndexes = spotMarketIndexes;
        this.oracleInfos = oracleInfos;
        this.shouldFindAllMarketsAndOracles = shouldFindAllMarketsAndOracles;
        this.resubOpts = resubOpts;
        this.commitment = commitment;
    }
    async subscribe() {
        if (this.isSubscribed) {
            return true;
        }
        if (this.isSubscribing) {
            return await this.subscriptionPromise;
        }
        this.isSubscribing = true;
        this.subscriptionPromise = new Promise((res) => {
            this.subscriptionPromiseResolver = res;
        });
        if (this.shouldFindAllMarketsAndOracles) {
            const { perpMarketIndexes, spotMarketIndexes, oracleInfos } = await (0, config_1.findAllMarketAndOracles)(this.program);
            this.perpMarketIndexes = perpMarketIndexes;
            this.spotMarketIndexes = spotMarketIndexes;
            this.oracleInfos = oracleInfos;
        }
        const statePublicKey = await (0, pda_1.getDriftStateAccountPublicKey)(this.program.programId);
        // create and activate main state account subscription
        this.stateAccountSubscriber = new webSocketAccountSubscriber_1.WebSocketAccountSubscriber('state', this.program, statePublicKey, undefined, undefined, this.commitment);
        await this.stateAccountSubscriber.subscribe((data) => {
            this.eventEmitter.emit('stateAccountUpdate', data);
            this.eventEmitter.emit('update');
        });
        // subscribe to market accounts
        await this.subscribeToPerpMarketAccounts();
        // subscribe to spot market accounts
        await this.subscribeToSpotMarketAccounts();
        // subscribe to oracles
        await this.subscribeToOracles();
        this.eventEmitter.emit('update');
        await this.setPerpOracleMap();
        await this.setSpotOracleMap();
        this.isSubscribing = false;
        this.isSubscribed = true;
        this.subscriptionPromiseResolver(true);
        return true;
    }
    async subscribeToPerpMarketAccounts() {
        for (const marketIndex of this.perpMarketIndexes) {
            await this.subscribeToPerpMarketAccount(marketIndex);
        }
        return true;
    }
    async subscribeToPerpMarketAccount(marketIndex) {
        const perpMarketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, marketIndex);
        const accountSubscriber = new webSocketAccountSubscriber_1.WebSocketAccountSubscriber('perpMarket', this.program, perpMarketPublicKey, undefined, this.resubOpts, this.commitment);
        await accountSubscriber.subscribe((data) => {
            this.eventEmitter.emit('perpMarketAccountUpdate', data);
            this.eventEmitter.emit('update');
        });
        this.perpMarketAccountSubscribers.set(marketIndex, accountSubscriber);
        return true;
    }
    async subscribeToSpotMarketAccounts() {
        for (const marketIndex of this.spotMarketIndexes) {
            await this.subscribeToSpotMarketAccount(marketIndex);
        }
        return true;
    }
    async subscribeToSpotMarketAccount(marketIndex) {
        const marketPublicKey = await (0, pda_1.getSpotMarketPublicKey)(this.program.programId, marketIndex);
        const accountSubscriber = new webSocketAccountSubscriber_1.WebSocketAccountSubscriber('spotMarket', this.program, marketPublicKey, undefined, this.resubOpts, this.commitment);
        await accountSubscriber.subscribe((data) => {
            this.eventEmitter.emit('spotMarketAccountUpdate', data);
            this.eventEmitter.emit('update');
        });
        this.spotMarketAccountSubscribers.set(marketIndex, accountSubscriber);
        return true;
    }
    async subscribeToOracles() {
        for (const oracleInfo of this.oracleInfos) {
            if (!oracleInfo.publicKey.equals(web3_js_1.PublicKey.default)) {
                await this.subscribeToOracle(oracleInfo);
            }
        }
        return true;
    }
    async subscribeToOracle(oracleInfo) {
        const client = this.oracleClientCache.get(oracleInfo.source, this.program.provider.connection, this.program);
        const accountSubscriber = new webSocketAccountSubscriber_1.WebSocketAccountSubscriber('oracle', this.program, oracleInfo.publicKey, (buffer) => {
            return client.getOraclePriceDataFromBuffer(buffer);
        }, this.resubOpts, this.commitment);
        await accountSubscriber.subscribe((data) => {
            this.eventEmitter.emit('oraclePriceUpdate', oracleInfo.publicKey, data);
            this.eventEmitter.emit('update');
        });
        this.oracleSubscribers.set(oracleInfo.publicKey.toString(), accountSubscriber);
        return true;
    }
    async unsubscribeFromMarketAccounts() {
        for (const accountSubscriber of this.perpMarketAccountSubscribers.values()) {
            await accountSubscriber.unsubscribe();
        }
    }
    async unsubscribeFromSpotMarketAccounts() {
        for (const accountSubscriber of this.spotMarketAccountSubscribers.values()) {
            await accountSubscriber.unsubscribe();
        }
    }
    async unsubscribeFromOracles() {
        for (const accountSubscriber of this.oracleSubscribers.values()) {
            await accountSubscriber.unsubscribe();
        }
    }
    async fetch() {
        if (!this.isSubscribed) {
            return;
        }
        const promises = [this.stateAccountSubscriber.fetch()]
            .concat(Array.from(this.perpMarketAccountSubscribers.values()).map((subscriber) => subscriber.fetch()))
            .concat(Array.from(this.spotMarketAccountSubscribers.values()).map((subscriber) => subscriber.fetch()));
        await Promise.all(promises);
    }
    async unsubscribe() {
        if (!this.isSubscribed) {
            return;
        }
        await this.stateAccountSubscriber.unsubscribe();
        await this.unsubscribeFromMarketAccounts();
        await this.unsubscribeFromSpotMarketAccounts();
        await this.unsubscribeFromOracles();
        this.isSubscribed = false;
    }
    async addSpotMarket(marketIndex) {
        if (this.spotMarketAccountSubscribers.has(marketIndex)) {
            return true;
        }
        const subscriptionSuccess = this.subscribeToSpotMarketAccount(marketIndex);
        await this.setSpotOracleMap();
        return subscriptionSuccess;
    }
    async addPerpMarket(marketIndex) {
        if (this.perpMarketAccountSubscribers.has(marketIndex)) {
            return true;
        }
        const subscriptionSuccess = this.subscribeToPerpMarketAccount(marketIndex);
        await this.setPerpOracleMap();
        return subscriptionSuccess;
    }
    async addOracle(oracleInfo) {
        if (this.oracleSubscribers.has(oracleInfo.publicKey.toString())) {
            return true;
        }
        if (oracleInfo.publicKey.equals(web3_js_1.PublicKey.default)) {
            return true;
        }
        return this.subscribeToOracle(oracleInfo);
    }
    async setPerpOracleMap() {
        const perpMarkets = this.getMarketAccountsAndSlots();
        for (const perpMarket of perpMarkets) {
            if (!perpMarket) {
                continue;
            }
            const perpMarketAccount = perpMarket.data;
            const perpMarketIndex = perpMarketAccount.marketIndex;
            const oracle = perpMarketAccount.amm.oracle;
            if (!this.oracleSubscribers.has(oracle.toBase58())) {
                await this.addOracle({
                    publicKey: oracle,
                    source: perpMarket.data.amm.oracleSource,
                });
            }
            this.perpOracleMap.set(perpMarketIndex, oracle);
        }
    }
    async setSpotOracleMap() {
        const spotMarkets = this.getSpotMarketAccountsAndSlots();
        for (const spotMarket of spotMarkets) {
            if (!spotMarket) {
                continue;
            }
            const spotMarketAccount = spotMarket.data;
            const spotMarketIndex = spotMarketAccount.marketIndex;
            const oracle = spotMarketAccount.oracle;
            if (!this.oracleSubscribers.has(oracle.toBase58())) {
                await this.addOracle({
                    publicKey: oracle,
                    source: spotMarketAccount.oracleSource,
                });
            }
            this.spotOracleMap.set(spotMarketIndex, oracle);
        }
    }
    assertIsSubscribed() {
        if (!this.isSubscribed) {
            throw new types_1.NotSubscribedError('You must call `subscribe` before using this function');
        }
    }
    getStateAccountAndSlot() {
        this.assertIsSubscribed();
        return this.stateAccountSubscriber.dataAndSlot;
    }
    getMarketAccountAndSlot(marketIndex) {
        this.assertIsSubscribed();
        return this.perpMarketAccountSubscribers.get(marketIndex).dataAndSlot;
    }
    getMarketAccountsAndSlots() {
        return Array.from(this.perpMarketAccountSubscribers.values()).map((subscriber) => subscriber.dataAndSlot);
    }
    getSpotMarketAccountAndSlot(marketIndex) {
        this.assertIsSubscribed();
        return this.spotMarketAccountSubscribers.get(marketIndex).dataAndSlot;
    }
    getSpotMarketAccountsAndSlots() {
        return Array.from(this.spotMarketAccountSubscribers.values()).map((subscriber) => subscriber.dataAndSlot);
    }
    getOraclePriceDataAndSlot(oraclePublicKey) {
        this.assertIsSubscribed();
        if (oraclePublicKey.equals(web3_js_1.PublicKey.default)) {
            return {
                data: quoteAssetOracleClient_1.QUOTE_ORACLE_PRICE_DATA,
                slot: 0,
            };
        }
        return this.oracleSubscribers.get(oraclePublicKey.toString()).dataAndSlot;
    }
    getOraclePriceDataAndSlotForPerpMarket(marketIndex) {
        const perpMarketAccount = this.getMarketAccountAndSlot(marketIndex);
        const oracle = this.perpOracleMap.get(marketIndex);
        if (!perpMarketAccount || !oracle) {
            return undefined;
        }
        if (!perpMarketAccount.data.amm.oracle.equals(oracle)) {
            // If the oracle has changed, we need to update the oracle map in background
            this.setPerpOracleMap();
        }
        return this.getOraclePriceDataAndSlot(oracle);
    }
    getOraclePriceDataAndSlotForSpotMarket(marketIndex) {
        const spotMarketAccount = this.getSpotMarketAccountAndSlot(marketIndex);
        const oracle = this.spotOracleMap.get(marketIndex);
        if (!spotMarketAccount || !oracle) {
            return undefined;
        }
        if (!spotMarketAccount.data.oracle.equals(oracle)) {
            // If the oracle has changed, we need to update the oracle map in background
            this.setSpotOracleMap();
        }
        return this.getOraclePriceDataAndSlot(oracle);
    }
}
exports.WebSocketDriftClientAccountSubscriber = WebSocketDriftClientAccountSubscriber;
