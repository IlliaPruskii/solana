/// <reference types="node" />
import { DataAndSlot, AccountToPoll, DriftClientAccountEvents, DriftClientAccountSubscriber, OraclesToPoll } from './types';
import { Program } from '@coral-xyz/anchor';
import StrictEventEmitter from 'strict-event-emitter-types';
import { EventEmitter } from 'events';
import { SpotMarketAccount, PerpMarketAccount, StateAccount, UserAccount } from '../types';
import { BulkAccountLoader } from './bulkAccountLoader';
import { PublicKey } from '@solana/web3.js';
import { OracleInfo, OraclePriceData } from '../oracles/types';
import { OracleClientCache } from '../oracles/oracleClientCache';
export declare class PollingDriftClientAccountSubscriber implements DriftClientAccountSubscriber {
    isSubscribed: boolean;
    program: Program;
    perpMarketIndexes: number[];
    spotMarketIndexes: number[];
    oracleInfos: OracleInfo[];
    oracleClientCache: OracleClientCache;
    shouldFindAllMarketsAndOracles: boolean;
    eventEmitter: StrictEventEmitter<EventEmitter, DriftClientAccountEvents>;
    accountLoader: BulkAccountLoader;
    accountsToPoll: Map<string, AccountToPoll>;
    oraclesToPoll: Map<string, OraclesToPoll>;
    errorCallbackId?: string;
    state?: DataAndSlot<StateAccount>;
    perpMarket: Map<number, DataAndSlot<PerpMarketAccount>>;
    perpOracleMap: Map<number, PublicKey>;
    spotMarket: Map<number, DataAndSlot<SpotMarketAccount>>;
    spotOracleMap: Map<number, PublicKey>;
    oracles: Map<string, DataAndSlot<OraclePriceData>>;
    user?: DataAndSlot<UserAccount>;
    private isSubscribing;
    private subscriptionPromise;
    private subscriptionPromiseResolver;
    constructor(program: Program, accountLoader: BulkAccountLoader, perpMarketIndexes: number[], spotMarketIndexes: number[], oracleInfos: OracleInfo[], shouldFindAllMarketsAndOracles: boolean);
    subscribe(): Promise<boolean>;
    updateAccountsToPoll(): Promise<void>;
    updatePerpMarketAccountsToPoll(): Promise<boolean>;
    addPerpMarketAccountToPoll(marketIndex: number): Promise<boolean>;
    updateSpotMarketAccountsToPoll(): Promise<boolean>;
    addSpotMarketAccountToPoll(marketIndex: number): Promise<boolean>;
    updateOraclesToPoll(): boolean;
    addOracleToPoll(oracleInfo: OracleInfo): boolean;
    addToAccountLoader(): Promise<void>;
    addAccountToAccountLoader(accountToPoll: AccountToPoll): Promise<void>;
    addOracleToAccountLoader(oracleToPoll: OraclesToPoll): Promise<void>;
    fetch(): Promise<void>;
    didSubscriptionSucceed(): boolean;
    unsubscribe(): Promise<void>;
    addSpotMarket(marketIndex: number): Promise<boolean>;
    addPerpMarket(marketIndex: number): Promise<boolean>;
    addOracle(oracleInfo: OracleInfo): Promise<boolean>;
    private pauseForOracleToBeAdded;
    setPerpOracleMap(): Promise<void>;
    setSpotOracleMap(): Promise<void>;
    assertIsSubscribed(): void;
    getStateAccountAndSlot(): DataAndSlot<StateAccount>;
    getMarketAccountAndSlot(marketIndex: number): DataAndSlot<PerpMarketAccount> | undefined;
    getMarketAccountsAndSlots(): DataAndSlot<PerpMarketAccount>[];
    getSpotMarketAccountAndSlot(marketIndex: number): DataAndSlot<SpotMarketAccount> | undefined;
    getSpotMarketAccountsAndSlots(): DataAndSlot<SpotMarketAccount>[];
    getOraclePriceDataAndSlot(oraclePublicKey: PublicKey): DataAndSlot<OraclePriceData> | undefined;
    getOraclePriceDataAndSlotForPerpMarket(marketIndex: number): DataAndSlot<OraclePriceData> | undefined;
    getOraclePriceDataAndSlotForSpotMarket(marketIndex: number): DataAndSlot<OraclePriceData> | undefined;
    updateAccountLoaderPollingFrequency(pollingFrequency: number): void;
}
